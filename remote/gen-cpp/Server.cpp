/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Server.h"

namespace thrift_codegen {


Server_connect_args::~Server_connect_args() noexcept {
}


uint32_t Server_connect_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->backwardConnectionPort);
          this->__isset.backwardConnectionPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cmdLineArgs.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->cmdLineArgs.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->cmdLineArgs[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cmdLineArgs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->settings.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _ktype6;
            ::apache::thrift::protocol::TType _vtype7;
            xfer += iprot->readMapBegin(_ktype6, _vtype7, _size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              std::string _key10;
              xfer += iprot->readString(_key10);
              std::string& _val11 = this->settings[_key10];
              xfer += iprot->readString(_val11);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.settings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_connect_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_connect_args");

  xfer += oprot->writeFieldBegin("backwardConnectionPort", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->backwardConnectionPort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmdLineArgs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cmdLineArgs.size()));
    std::vector<std::string> ::const_iterator _iter12;
    for (_iter12 = this->cmdLineArgs.begin(); _iter12 != this->cmdLineArgs.end(); ++_iter12)
    {
      xfer += oprot->writeString((*_iter12));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("settings", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->settings.size()));
    std::map<std::string, std::string> ::const_iterator _iter13;
    for (_iter13 = this->settings.begin(); _iter13 != this->settings.end(); ++_iter13)
    {
      xfer += oprot->writeString(_iter13->first);
      xfer += oprot->writeString(_iter13->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_connect_pargs::~Server_connect_pargs() noexcept {
}


uint32_t Server_connect_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_connect_pargs");

  xfer += oprot->writeFieldBegin("backwardConnectionPort", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->backwardConnectionPort)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmdLineArgs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->cmdLineArgs)).size()));
    std::vector<std::string> ::const_iterator _iter14;
    for (_iter14 = (*(this->cmdLineArgs)).begin(); _iter14 != (*(this->cmdLineArgs)).end(); ++_iter14)
    {
      xfer += oprot->writeString((*_iter14));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("settings", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->settings)).size()));
    std::map<std::string, std::string> ::const_iterator _iter15;
    for (_iter15 = (*(this->settings)).begin(); _iter15 != (*(this->settings)).end(); ++_iter15)
    {
      xfer += oprot->writeString(_iter15->first);
      xfer += oprot->writeString(_iter15->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_connect_result::~Server_connect_result() noexcept {
}


uint32_t Server_connect_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_connect_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_connect_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_connect_presult::~Server_connect_presult() noexcept {
}


uint32_t Server_connect_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_log_args::~Server_log_args() noexcept {
}


uint32_t Server_log_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_log_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_log_args");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_log_pargs::~Server_log_pargs() noexcept {
}


uint32_t Server_log_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_log_pargs");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->msg)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_createBrowser_args::~Server_createBrowser_args() noexcept {
}


uint32_t Server_createBrowser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_createBrowser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_createBrowser_args");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_createBrowser_pargs::~Server_createBrowser_pargs() noexcept {
}


uint32_t Server_createBrowser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_createBrowser_pargs");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->cid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_createBrowser_result::~Server_createBrowser_result() noexcept {
}


uint32_t Server_createBrowser_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_createBrowser_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_createBrowser_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_createBrowser_presult::~Server_createBrowser_presult() noexcept {
}


uint32_t Server_createBrowser_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_closeBrowser_args::~Server_closeBrowser_args() noexcept {
}


uint32_t Server_closeBrowser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_closeBrowser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_closeBrowser_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_closeBrowser_pargs::~Server_closeBrowser_pargs() noexcept {
}


uint32_t Server_closeBrowser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_closeBrowser_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Reload_args::~Server_Browser_Reload_args() noexcept {
}


uint32_t Server_Browser_Reload_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_Reload_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_Reload_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_Reload_pargs::~Server_Browser_Reload_pargs() noexcept {
}


uint32_t Server_Browser_Reload_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_Reload_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_ReloadIgnoreCache_args::~Server_Browser_ReloadIgnoreCache_args() noexcept {
}


uint32_t Server_Browser_ReloadIgnoreCache_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_ReloadIgnoreCache_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ReloadIgnoreCache_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_ReloadIgnoreCache_pargs::~Server_Browser_ReloadIgnoreCache_pargs() noexcept {
}


uint32_t Server_Browser_ReloadIgnoreCache_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ReloadIgnoreCache_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_LoadURL_args::~Server_Browser_LoadURL_args() noexcept {
}


uint32_t Server_Browser_LoadURL_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_LoadURL_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_LoadURL_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_LoadURL_pargs::~Server_Browser_LoadURL_pargs() noexcept {
}


uint32_t Server_Browser_LoadURL_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_LoadURL_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetURL_args::~Server_Browser_GetURL_args() noexcept {
}


uint32_t Server_Browser_GetURL_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetURL_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetURL_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetURL_pargs::~Server_Browser_GetURL_pargs() noexcept {
}


uint32_t Server_Browser_GetURL_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_GetURL_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetURL_result::~Server_Browser_GetURL_result() noexcept {
}


uint32_t Server_Browser_GetURL_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_GetURL_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Browser_GetURL_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_GetURL_presult::~Server_Browser_GetURL_presult() noexcept {
}


uint32_t Server_Browser_GetURL_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Browser_ExecuteJavaScript_args::~Server_Browser_ExecuteJavaScript_args() noexcept {
}


uint32_t Server_Browser_ExecuteJavaScript_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->line);
          this->__isset.line = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_ExecuteJavaScript_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ExecuteJavaScript_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->line);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_ExecuteJavaScript_pargs::~Server_Browser_ExecuteJavaScript_pargs() noexcept {
}


uint32_t Server_Browser_ExecuteJavaScript_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_ExecuteJavaScript_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->line)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_WasResized_args::~Server_Browser_WasResized_args() noexcept {
}


uint32_t Server_Browser_WasResized_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_WasResized_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_WasResized_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_WasResized_pargs::~Server_Browser_WasResized_pargs() noexcept {
}


uint32_t Server_Browser_WasResized_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_WasResized_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->width)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->height)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendKeyEvent_args::~Server_Browser_SendKeyEvent_args() noexcept {
}


uint32_t Server_Browser_SendKeyEvent_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->event_type);
          this->__isset.event_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->modifiers);
          this->__isset.modifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->key_char);
          this->__isset.key_char = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->scanCode);
          this->__isset.scanCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_code);
          this->__isset.key_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_SendKeyEvent_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendKeyEvent_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("event_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->event_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->modifiers);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_char", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->key_char);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scanCode", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->scanCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_code", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->key_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendKeyEvent_pargs::~Server_Browser_SendKeyEvent_pargs() noexcept {
}


uint32_t Server_Browser_SendKeyEvent_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendKeyEvent_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("event_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->event_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->modifiers)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_char", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16((*(this->key_char)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scanCode", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->scanCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_code", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->key_code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendMouseEvent_args::~Server_Browser_SendMouseEvent_args() noexcept {
}


uint32_t Server_Browser_SendMouseEvent_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->event_type);
          this->__isset.event_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->modifiers);
          this->__isset.modifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->click_count);
          this->__isset.click_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->button);
          this->__isset.button = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_SendMouseEvent_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendMouseEvent_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("event_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->event_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->modifiers);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("click_count", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->click_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("button", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->button);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendMouseEvent_pargs::~Server_Browser_SendMouseEvent_pargs() noexcept {
}


uint32_t Server_Browser_SendMouseEvent_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendMouseEvent_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("event_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->event_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->x)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->y)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->modifiers)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("click_count", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->click_count)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("button", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((*(this->button)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendMouseWheelEvent_args::~Server_Browser_SendMouseWheelEvent_args() noexcept {
}


uint32_t Server_Browser_SendMouseWheelEvent_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scroll_type);
          this->__isset.scroll_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->modifiers);
          this->__isset.modifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->delta);
          this->__isset.delta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->units_to_scroll);
          this->__isset.units_to_scroll = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Browser_SendMouseWheelEvent_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendMouseWheelEvent_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scroll_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->scroll_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->modifiers);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delta", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->delta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("units_to_scroll", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->units_to_scroll);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Browser_SendMouseWheelEvent_pargs::~Server_Browser_SendMouseWheelEvent_pargs() noexcept {
}


uint32_t Server_Browser_SendMouseWheelEvent_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Browser_SendMouseWheelEvent_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scroll_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->scroll_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->x)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->y)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->modifiers)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delta", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->delta)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("units_to_scroll", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((*(this->units_to_scroll)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Update_args::~Server_Request_Update_args() noexcept {
}


uint32_t Server_Request_Update_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_Update_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Update_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Update_pargs::~Server_Request_Update_pargs() noexcept {
}


uint32_t Server_Request_Update_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Update_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Update_result::~Server_Request_Update_result() noexcept {
}


uint32_t Server_Request_Update_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_Update_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_Update_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Update_presult::~Server_Request_Update_presult() noexcept {
}


uint32_t Server_Request_Update_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_GetPostData_args::~Server_Request_GetPostData_args() noexcept {
}


uint32_t Server_Request_GetPostData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetPostData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetPostData_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetPostData_pargs::~Server_Request_GetPostData_pargs() noexcept {
}


uint32_t Server_Request_GetPostData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetPostData_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetPostData_result::~Server_Request_GetPostData_result() noexcept {
}


uint32_t Server_Request_GetPostData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetPostData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_GetPostData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetPostData_presult::~Server_Request_GetPostData_presult() noexcept {
}


uint32_t Server_Request_GetPostData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_SetPostData_args::~Server_Request_SetPostData_args() noexcept {
}


uint32_t Server_Request_SetPostData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->postData.read(iprot);
          this->__isset.postData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetPostData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetPostData_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("postData", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->postData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetPostData_pargs::~Server_Request_SetPostData_pargs() noexcept {
}


uint32_t Server_Request_SetPostData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetPostData_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("postData", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->postData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetPostData_result::~Server_Request_SetPostData_result() noexcept {
}


uint32_t Server_Request_SetPostData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetPostData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_SetPostData_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetPostData_presult::~Server_Request_SetPostData_presult() noexcept {
}


uint32_t Server_Request_SetPostData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_GetHeaderByName_args::~Server_Request_GetHeaderByName_args() noexcept {
}


uint32_t Server_Request_GetHeaderByName_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetHeaderByName_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetHeaderByName_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderByName_pargs::~Server_Request_GetHeaderByName_pargs() noexcept {
}


uint32_t Server_Request_GetHeaderByName_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetHeaderByName_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderByName_result::~Server_Request_GetHeaderByName_result() noexcept {
}


uint32_t Server_Request_GetHeaderByName_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetHeaderByName_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_GetHeaderByName_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderByName_presult::~Server_Request_GetHeaderByName_presult() noexcept {
}


uint32_t Server_Request_GetHeaderByName_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_SetHeaderByName_args::~Server_Request_SetHeaderByName_args() noexcept {
}


uint32_t Server_Request_SetHeaderByName_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->overwrite);
          this->__isset.overwrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetHeaderByName_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetHeaderByName_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overwrite", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->overwrite);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderByName_pargs::~Server_Request_SetHeaderByName_pargs() noexcept {
}


uint32_t Server_Request_SetHeaderByName_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetHeaderByName_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overwrite", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->overwrite)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderByName_result::~Server_Request_SetHeaderByName_result() noexcept {
}


uint32_t Server_Request_SetHeaderByName_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetHeaderByName_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_SetHeaderByName_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderByName_presult::~Server_Request_SetHeaderByName_presult() noexcept {
}


uint32_t Server_Request_SetHeaderByName_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_GetHeaderMap_args::~Server_Request_GetHeaderMap_args() noexcept {
}


uint32_t Server_Request_GetHeaderMap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetHeaderMap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetHeaderMap_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderMap_pargs::~Server_Request_GetHeaderMap_pargs() noexcept {
}


uint32_t Server_Request_GetHeaderMap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_GetHeaderMap_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderMap_result::~Server_Request_GetHeaderMap_result() noexcept {
}


uint32_t Server_Request_GetHeaderMap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _ktype17;
            ::apache::thrift::protocol::TType _vtype18;
            xfer += iprot->readMapBegin(_ktype17, _vtype18, _size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              std::string _key21;
              xfer += iprot->readString(_key21);
              std::string& _val22 = this->success[_key21];
              xfer += iprot->readString(_val22);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_GetHeaderMap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_GetHeaderMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter23;
      for (_iter23 = this->success.begin(); _iter23 != this->success.end(); ++_iter23)
      {
        xfer += oprot->writeString(_iter23->first);
        xfer += oprot->writeString(_iter23->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_GetHeaderMap_presult::~Server_Request_GetHeaderMap_presult() noexcept {
}


uint32_t Server_Request_GetHeaderMap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _ktype25;
            ::apache::thrift::protocol::TType _vtype26;
            xfer += iprot->readMapBegin(_ktype25, _vtype26, _size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              std::string _key29;
              xfer += iprot->readString(_key29);
              std::string& _val30 = (*(this->success))[_key29];
              xfer += iprot->readString(_val30);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_SetHeaderMap_args::~Server_Request_SetHeaderMap_args() noexcept {
}


uint32_t Server_Request_SetHeaderMap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->headerMap.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _ktype32;
            ::apache::thrift::protocol::TType _vtype33;
            xfer += iprot->readMapBegin(_ktype32, _vtype33, _size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              std::string _key36;
              xfer += iprot->readString(_key36);
              std::string& _val37 = this->headerMap[_key36];
              xfer += iprot->readString(_val37);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.headerMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetHeaderMap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetHeaderMap_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headerMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter38;
    for (_iter38 = this->headerMap.begin(); _iter38 != this->headerMap.end(); ++_iter38)
    {
      xfer += oprot->writeString(_iter38->first);
      xfer += oprot->writeString(_iter38->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderMap_pargs::~Server_Request_SetHeaderMap_pargs() noexcept {
}


uint32_t Server_Request_SetHeaderMap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_SetHeaderMap_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->headerMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter39;
    for (_iter39 = (*(this->headerMap)).begin(); _iter39 != (*(this->headerMap)).end(); ++_iter39)
    {
      xfer += oprot->writeString(_iter39->first);
      xfer += oprot->writeString(_iter39->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderMap_result::~Server_Request_SetHeaderMap_result() noexcept {
}


uint32_t Server_Request_SetHeaderMap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_SetHeaderMap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_SetHeaderMap_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_SetHeaderMap_presult::~Server_Request_SetHeaderMap_presult() noexcept {
}


uint32_t Server_Request_SetHeaderMap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Request_Set_args::~Server_Request_Set_args() noexcept {
}


uint32_t Server_Request_Set_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->postData.read(iprot);
          this->__isset.postData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->headerMap.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _ktype41;
            ::apache::thrift::protocol::TType _vtype42;
            xfer += iprot->readMapBegin(_ktype41, _vtype42, _size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              std::string _key45;
              xfer += iprot->readString(_key45);
              std::string& _val46 = this->headerMap[_key45];
              xfer += iprot->readString(_val46);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.headerMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_Set_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Set_args");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("postData", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->postData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headerMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter47;
    for (_iter47 = this->headerMap.begin(); _iter47 != this->headerMap.end(); ++_iter47)
    {
      xfer += oprot->writeString(_iter47->first);
      xfer += oprot->writeString(_iter47->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Set_pargs::~Server_Request_Set_pargs() noexcept {
}


uint32_t Server_Request_Set_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Request_Set_pargs");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->method)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("postData", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->postData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->headerMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter48;
    for (_iter48 = (*(this->headerMap)).begin(); _iter48 != (*(this->headerMap)).end(); ++_iter48)
    {
      xfer += oprot->writeString(_iter48->first);
      xfer += oprot->writeString(_iter48->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Set_result::~Server_Request_Set_result() noexcept {
}


uint32_t Server_Request_Set_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Request_Set_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Request_Set_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Request_Set_presult::~Server_Request_Set_presult() noexcept {
}


uint32_t Server_Request_Set_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Response_Update_args::~Server_Response_Update_args() noexcept {
}


uint32_t Server_Response_Update_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_Update_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_Update_args");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_Update_pargs::~Server_Response_Update_pargs() noexcept {
}


uint32_t Server_Response_Update_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_Update_pargs");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_Update_result::~Server_Response_Update_result() noexcept {
}


uint32_t Server_Response_Update_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_Update_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Response_Update_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_Update_presult::~Server_Response_Update_presult() noexcept {
}


uint32_t Server_Response_Update_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Response_GetHeaderByName_args::~Server_Response_GetHeaderByName_args() noexcept {
}


uint32_t Server_Response_GetHeaderByName_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_GetHeaderByName_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_GetHeaderByName_args");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderByName_pargs::~Server_Response_GetHeaderByName_pargs() noexcept {
}


uint32_t Server_Response_GetHeaderByName_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_GetHeaderByName_pargs");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderByName_result::~Server_Response_GetHeaderByName_result() noexcept {
}


uint32_t Server_Response_GetHeaderByName_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_GetHeaderByName_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Response_GetHeaderByName_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderByName_presult::~Server_Response_GetHeaderByName_presult() noexcept {
}


uint32_t Server_Response_GetHeaderByName_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Response_SetHeaderByName_args::~Server_Response_SetHeaderByName_args() noexcept {
}


uint32_t Server_Response_SetHeaderByName_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->overwrite);
          this->__isset.overwrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_SetHeaderByName_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_SetHeaderByName_args");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overwrite", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->overwrite);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderByName_pargs::~Server_Response_SetHeaderByName_pargs() noexcept {
}


uint32_t Server_Response_SetHeaderByName_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_SetHeaderByName_pargs");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overwrite", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->overwrite)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderByName_result::~Server_Response_SetHeaderByName_result() noexcept {
}


uint32_t Server_Response_SetHeaderByName_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_SetHeaderByName_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Response_SetHeaderByName_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderByName_presult::~Server_Response_SetHeaderByName_presult() noexcept {
}


uint32_t Server_Response_SetHeaderByName_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Response_GetHeaderMap_args::~Server_Response_GetHeaderMap_args() noexcept {
}


uint32_t Server_Response_GetHeaderMap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_GetHeaderMap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_GetHeaderMap_args");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderMap_pargs::~Server_Response_GetHeaderMap_pargs() noexcept {
}


uint32_t Server_Response_GetHeaderMap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_GetHeaderMap_pargs");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderMap_result::~Server_Response_GetHeaderMap_result() noexcept {
}


uint32_t Server_Response_GetHeaderMap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _ktype50;
            ::apache::thrift::protocol::TType _vtype51;
            xfer += iprot->readMapBegin(_ktype50, _vtype51, _size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              std::string _key54;
              xfer += iprot->readString(_key54);
              std::string& _val55 = this->success[_key54];
              xfer += iprot->readString(_val55);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_GetHeaderMap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Response_GetHeaderMap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::string> ::const_iterator _iter56;
      for (_iter56 = this->success.begin(); _iter56 != this->success.end(); ++_iter56)
      {
        xfer += oprot->writeString(_iter56->first);
        xfer += oprot->writeString(_iter56->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_GetHeaderMap_presult::~Server_Response_GetHeaderMap_presult() noexcept {
}


uint32_t Server_Response_GetHeaderMap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _ktype58;
            ::apache::thrift::protocol::TType _vtype59;
            xfer += iprot->readMapBegin(_ktype58, _vtype59, _size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              std::string _key62;
              xfer += iprot->readString(_key62);
              std::string& _val63 = (*(this->success))[_key62];
              xfer += iprot->readString(_val63);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Response_SetHeaderMap_args::~Server_Response_SetHeaderMap_args() noexcept {
}


uint32_t Server_Response_SetHeaderMap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->headerMap.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _ktype65;
            ::apache::thrift::protocol::TType _vtype66;
            xfer += iprot->readMapBegin(_ktype65, _vtype66, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              std::string _key69;
              xfer += iprot->readString(_key69);
              std::string& _val70 = this->headerMap[_key69];
              xfer += iprot->readString(_val70);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.headerMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_SetHeaderMap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_SetHeaderMap_args");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headerMap.size()));
    std::map<std::string, std::string> ::const_iterator _iter71;
    for (_iter71 = this->headerMap.begin(); _iter71 != this->headerMap.end(); ++_iter71)
    {
      xfer += oprot->writeString(_iter71->first);
      xfer += oprot->writeString(_iter71->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderMap_pargs::~Server_Response_SetHeaderMap_pargs() noexcept {
}


uint32_t Server_Response_SetHeaderMap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Response_SetHeaderMap_pargs");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headerMap", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->headerMap)).size()));
    std::map<std::string, std::string> ::const_iterator _iter72;
    for (_iter72 = (*(this->headerMap)).begin(); _iter72 != (*(this->headerMap)).end(); ++_iter72)
    {
      xfer += oprot->writeString(_iter72->first);
      xfer += oprot->writeString(_iter72->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderMap_result::~Server_Response_SetHeaderMap_result() noexcept {
}


uint32_t Server_Response_SetHeaderMap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Response_SetHeaderMap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_Response_SetHeaderMap_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Response_SetHeaderMap_presult::~Server_Response_SetHeaderMap_presult() noexcept {
}


uint32_t Server_Response_SetHeaderMap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_Callback_Dispose_args::~Server_Callback_Dispose_args() noexcept {
}


uint32_t Server_Callback_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->callback.read(iprot);
          this->__isset.callback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Callback_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Dispose_args");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->callback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Callback_Dispose_pargs::~Server_Callback_Dispose_pargs() noexcept {
}


uint32_t Server_Callback_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Dispose_pargs");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->callback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Callback_Continue_args::~Server_Callback_Continue_args() noexcept {
}


uint32_t Server_Callback_Continue_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->callback.read(iprot);
          this->__isset.callback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Callback_Continue_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Continue_args");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->callback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Callback_Continue_pargs::~Server_Callback_Continue_pargs() noexcept {
}


uint32_t Server_Callback_Continue_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Continue_pargs");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->callback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Callback_Cancel_args::~Server_Callback_Cancel_args() noexcept {
}


uint32_t Server_Callback_Cancel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->callback.read(iprot);
          this->__isset.callback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_Callback_Cancel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Cancel_args");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->callback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_Callback_Cancel_pargs::~Server_Callback_Cancel_pargs() noexcept {
}


uint32_t Server_Callback_Cancel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_Callback_Cancel_pargs");

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->callback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Dispose_args::~Server_AuthCallback_Dispose_args() noexcept {
}


uint32_t Server_AuthCallback_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authCallback.read(iprot);
          this->__isset.authCallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_AuthCallback_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Dispose_args");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->authCallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Dispose_pargs::~Server_AuthCallback_Dispose_pargs() noexcept {
}


uint32_t Server_AuthCallback_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Dispose_pargs");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->authCallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Continue_args::~Server_AuthCallback_Continue_args() noexcept {
}


uint32_t Server_AuthCallback_Continue_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authCallback.read(iprot);
          this->__isset.authCallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_AuthCallback_Continue_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Continue_args");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->authCallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->username);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Continue_pargs::~Server_AuthCallback_Continue_pargs() noexcept {
}


uint32_t Server_AuthCallback_Continue_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Continue_pargs");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->authCallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->username)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->password)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Cancel_args::~Server_AuthCallback_Cancel_args() noexcept {
}


uint32_t Server_AuthCallback_Cancel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authCallback.read(iprot);
          this->__isset.authCallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_AuthCallback_Cancel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Cancel_args");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->authCallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_AuthCallback_Cancel_pargs::~Server_AuthCallback_Cancel_pargs() noexcept {
}


uint32_t Server_AuthCallback_Cancel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_AuthCallback_Cancel_pargs");

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->authCallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_Create_args::~Server_MessageRouter_Create_args() noexcept {
}


uint32_t Server_MessageRouter_Create_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query);
          this->__isset.query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cancel);
          this->__isset.cancel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_Create_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_Create_args");

  xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->query);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cancel", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->cancel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_Create_pargs::~Server_MessageRouter_Create_pargs() noexcept {
}


uint32_t Server_MessageRouter_Create_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_Create_pargs");

  xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->query)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cancel", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->cancel)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_Create_result::~Server_MessageRouter_Create_result() noexcept {
}


uint32_t Server_MessageRouter_Create_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_Create_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_Create_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_Create_presult::~Server_MessageRouter_Create_presult() noexcept {
}


uint32_t Server_MessageRouter_Create_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_MessageRouter_Dispose_args::~Server_MessageRouter_Dispose_args() noexcept {
}


uint32_t Server_MessageRouter_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_Dispose_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_Dispose_pargs::~Server_MessageRouter_Dispose_pargs() noexcept {
}


uint32_t Server_MessageRouter_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_Dispose_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddMessageRouterToBrowser_args::~Server_MessageRouter_AddMessageRouterToBrowser_args() noexcept {
}


uint32_t Server_MessageRouter_AddMessageRouterToBrowser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_AddMessageRouterToBrowser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_AddMessageRouterToBrowser_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddMessageRouterToBrowser_pargs::~Server_MessageRouter_AddMessageRouterToBrowser_pargs() noexcept {
}


uint32_t Server_MessageRouter_AddMessageRouterToBrowser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_AddMessageRouterToBrowser_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddMessageRouterToBrowser_result::~Server_MessageRouter_AddMessageRouterToBrowser_result() noexcept {
}


uint32_t Server_MessageRouter_AddMessageRouterToBrowser_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_AddMessageRouterToBrowser_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_AddMessageRouterToBrowser_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddMessageRouterToBrowser_presult::~Server_MessageRouter_AddMessageRouterToBrowser_presult() noexcept {
}


uint32_t Server_MessageRouter_AddMessageRouterToBrowser_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_MessageRouter_RemoveMessageRouterFromBrowser_args::~Server_MessageRouter_RemoveMessageRouterFromBrowser_args() noexcept {
}


uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveMessageRouterFromBrowser_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs::~Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs() noexcept {
}


uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveMessageRouterFromBrowser_result::~Server_MessageRouter_RemoveMessageRouterFromBrowser_result() noexcept {
}


uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveMessageRouterFromBrowser_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveMessageRouterFromBrowser_presult::~Server_MessageRouter_RemoveMessageRouterFromBrowser_presult() noexcept {
}


uint32_t Server_MessageRouter_RemoveMessageRouterFromBrowser_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_MessageRouter_AddHandler_args::~Server_MessageRouter_AddHandler_args() noexcept {
}


uint32_t Server_MessageRouter_AddHandler_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->handler.read(iprot);
          this->__isset.handler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->first);
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_AddHandler_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_AddHandler_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->handler.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->first);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddHandler_pargs::~Server_MessageRouter_AddHandler_pargs() noexcept {
}


uint32_t Server_MessageRouter_AddHandler_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_AddHandler_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->handler)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->first)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddHandler_result::~Server_MessageRouter_AddHandler_result() noexcept {
}


uint32_t Server_MessageRouter_AddHandler_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_AddHandler_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_AddHandler_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_AddHandler_presult::~Server_MessageRouter_AddHandler_presult() noexcept {
}


uint32_t Server_MessageRouter_AddHandler_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_MessageRouter_RemoveHandler_args::~Server_MessageRouter_RemoveHandler_args() noexcept {
}


uint32_t Server_MessageRouter_RemoveHandler_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->handler.read(iprot);
          this->__isset.handler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_RemoveHandler_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveHandler_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->handler.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveHandler_pargs::~Server_MessageRouter_RemoveHandler_pargs() noexcept {
}


uint32_t Server_MessageRouter_RemoveHandler_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveHandler_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->handler)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveHandler_result::~Server_MessageRouter_RemoveHandler_result() noexcept {
}


uint32_t Server_MessageRouter_RemoveHandler_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_RemoveHandler_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_RemoveHandler_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_RemoveHandler_presult::~Server_MessageRouter_RemoveHandler_presult() noexcept {
}


uint32_t Server_MessageRouter_RemoveHandler_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_MessageRouter_CancelPending_args::~Server_MessageRouter_CancelPending_args() noexcept {
}


uint32_t Server_MessageRouter_CancelPending_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->msgRouter.read(iprot);
          this->__isset.msgRouter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->handler.read(iprot);
          this->__isset.handler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_CancelPending_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_CancelPending_args");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->msgRouter.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->handler.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_CancelPending_pargs::~Server_MessageRouter_CancelPending_pargs() noexcept {
}


uint32_t Server_MessageRouter_CancelPending_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_MessageRouter_CancelPending_pargs");

  xfer += oprot->writeFieldBegin("msgRouter", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->msgRouter)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->handler)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_CancelPending_result::~Server_MessageRouter_CancelPending_result() noexcept {
}


uint32_t Server_MessageRouter_CancelPending_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_MessageRouter_CancelPending_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Server_MessageRouter_CancelPending_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_MessageRouter_CancelPending_presult::~Server_MessageRouter_CancelPending_presult() noexcept {
}


uint32_t Server_MessageRouter_CancelPending_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Server_QueryCallback_Dispose_args::~Server_QueryCallback_Dispose_args() noexcept {
}


uint32_t Server_QueryCallback_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->qcallback.read(iprot);
          this->__isset.qcallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_QueryCallback_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Dispose_args");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->qcallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_QueryCallback_Dispose_pargs::~Server_QueryCallback_Dispose_pargs() noexcept {
}


uint32_t Server_QueryCallback_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Dispose_pargs");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->qcallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_QueryCallback_Success_args::~Server_QueryCallback_Success_args() noexcept {
}


uint32_t Server_QueryCallback_Success_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->qcallback.read(iprot);
          this->__isset.qcallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_QueryCallback_Success_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Success_args");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->qcallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_QueryCallback_Success_pargs::~Server_QueryCallback_Success_pargs() noexcept {
}


uint32_t Server_QueryCallback_Success_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Success_pargs");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->qcallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->response)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_QueryCallback_Failure_args::~Server_QueryCallback_Failure_args() noexcept {
}


uint32_t Server_QueryCallback_Failure_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->qcallback.read(iprot);
          this->__isset.qcallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_message);
          this->__isset.error_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Server_QueryCallback_Failure_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Failure_args");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->qcallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->error_message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Server_QueryCallback_Failure_pargs::~Server_QueryCallback_Failure_pargs() noexcept {
}


uint32_t Server_QueryCallback_Failure_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Server_QueryCallback_Failure_pargs");

  xfer += oprot->writeFieldBegin("qcallback", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->qcallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->error_code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->error_message)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

int32_t ServerClient::connect(const int32_t backwardConnectionPort, const std::vector<std::string> & cmdLineArgs, const std::map<std::string, std::string> & settings)
{
  send_connect(backwardConnectionPort, cmdLineArgs, settings);
  return recv_connect();
}

void ServerClient::send_connect(const int32_t backwardConnectionPort, const std::vector<std::string> & cmdLineArgs, const std::map<std::string, std::string> & settings)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("connect", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_connect_pargs args;
  args.backwardConnectionPort = &backwardConnectionPort;
  args.cmdLineArgs = &cmdLineArgs;
  args.settings = &settings;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t ServerClient::recv_connect()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("connect") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  Server_connect_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connect failed: unknown result");
}

void ServerClient::log(const std::string& msg)
{
  send_log(msg);
}

void ServerClient::send_log(const std::string& msg)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("log", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_log_pargs args;
  args.msg = &msg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t ServerClient::createBrowser(const int32_t cid, const std::string& url)
{
  send_createBrowser(cid, url);
  return recv_createBrowser();
}

void ServerClient::send_createBrowser(const int32_t cid, const std::string& url)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("createBrowser", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_createBrowser_pargs args;
  args.cid = &cid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t ServerClient::recv_createBrowser()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("createBrowser") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  Server_createBrowser_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createBrowser failed: unknown result");
}

void ServerClient::closeBrowser(const int32_t bid)
{
  send_closeBrowser(bid);
}

void ServerClient::send_closeBrowser(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeBrowser", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_closeBrowser_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_Reload(const int32_t bid)
{
  send_Browser_Reload(bid);
}

void ServerClient::send_Browser_Reload(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_Reload", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_Reload_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_ReloadIgnoreCache(const int32_t bid)
{
  send_Browser_ReloadIgnoreCache(bid);
}

void ServerClient::send_Browser_ReloadIgnoreCache(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_ReloadIgnoreCache", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ReloadIgnoreCache_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_LoadURL(const int32_t bid, const std::string& url)
{
  send_Browser_LoadURL(bid, url);
}

void ServerClient::send_Browser_LoadURL(const int32_t bid, const std::string& url)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_LoadURL", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_LoadURL_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_GetURL(std::string& _return, const int32_t bid)
{
  send_Browser_GetURL(bid);
  recv_Browser_GetURL(_return);
}

void ServerClient::send_Browser_GetURL(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_GetURL", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetURL_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Browser_GetURL(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Browser_GetURL") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Browser_GetURL_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetURL failed: unknown result");
}

void ServerClient::Browser_ExecuteJavaScript(const int32_t bid, const std::string& code, const std::string& url, const int32_t line)
{
  send_Browser_ExecuteJavaScript(bid, code, url, line);
}

void ServerClient::send_Browser_ExecuteJavaScript(const int32_t bid, const std::string& code, const std::string& url, const int32_t line)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_ExecuteJavaScript", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ExecuteJavaScript_pargs args;
  args.bid = &bid;
  args.code = &code;
  args.url = &url;
  args.line = &line;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_WasResized(const int32_t bid, const int32_t width, const int32_t height)
{
  send_Browser_WasResized(bid, width, height);
}

void ServerClient::send_Browser_WasResized(const int32_t bid, const int32_t width, const int32_t height)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_WasResized", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_WasResized_pargs args;
  args.bid = &bid;
  args.width = &width;
  args.height = &height;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_SendKeyEvent(const int32_t bid, const int32_t event_type, const int32_t modifiers, const int16_t key_char, const int64_t scanCode, const int32_t key_code)
{
  send_Browser_SendKeyEvent(bid, event_type, modifiers, key_char, scanCode, key_code);
}

void ServerClient::send_Browser_SendKeyEvent(const int32_t bid, const int32_t event_type, const int32_t modifiers, const int16_t key_char, const int64_t scanCode, const int32_t key_code)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_SendKeyEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendKeyEvent_pargs args;
  args.bid = &bid;
  args.event_type = &event_type;
  args.modifiers = &modifiers;
  args.key_char = &key_char;
  args.scanCode = &scanCode;
  args.key_code = &key_code;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_SendMouseEvent(const int32_t bid, const int32_t event_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t click_count, const int32_t button)
{
  send_Browser_SendMouseEvent(bid, event_type, x, y, modifiers, click_count, button);
}

void ServerClient::send_Browser_SendMouseEvent(const int32_t bid, const int32_t event_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t click_count, const int32_t button)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_SendMouseEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendMouseEvent_pargs args;
  args.bid = &bid;
  args.event_type = &event_type;
  args.x = &x;
  args.y = &y;
  args.modifiers = &modifiers;
  args.click_count = &click_count;
  args.button = &button;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Browser_SendMouseWheelEvent(const int32_t bid, const int32_t scroll_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t delta, const int32_t units_to_scroll)
{
  send_Browser_SendMouseWheelEvent(bid, scroll_type, x, y, modifiers, delta, units_to_scroll);
}

void ServerClient::send_Browser_SendMouseWheelEvent(const int32_t bid, const int32_t scroll_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t delta, const int32_t units_to_scroll)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Browser_SendMouseWheelEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendMouseWheelEvent_pargs args;
  args.bid = &bid;
  args.scroll_type = &scroll_type;
  args.x = &x;
  args.y = &y;
  args.modifiers = &modifiers;
  args.delta = &delta;
  args.units_to_scroll = &units_to_scroll;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Request_Update(const  ::thrift_codegen::RObject& request)
{
  send_Request_Update(request);
  recv_Request_Update();
}

void ServerClient::send_Request_Update(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_Update", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_Update_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_Update()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_Update") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_Update_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Request_GetPostData( ::thrift_codegen::PostData& _return, const  ::thrift_codegen::RObject& request)
{
  send_Request_GetPostData(request);
  recv_Request_GetPostData(_return);
}

void ServerClient::send_Request_GetPostData(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_GetPostData", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetPostData_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_GetPostData( ::thrift_codegen::PostData& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_GetPostData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_GetPostData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetPostData failed: unknown result");
}

void ServerClient::Request_SetPostData(const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::PostData& postData)
{
  send_Request_SetPostData(request, postData);
  recv_Request_SetPostData();
}

void ServerClient::send_Request_SetPostData(const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::PostData& postData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_SetPostData", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetPostData_pargs args;
  args.request = &request;
  args.postData = &postData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_SetPostData()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_SetPostData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_SetPostData_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Request_GetHeaderByName(std::string& _return, const  ::thrift_codegen::RObject& request, const std::string& name)
{
  send_Request_GetHeaderByName(request, name);
  recv_Request_GetHeaderByName(_return);
}

void ServerClient::send_Request_GetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_GetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetHeaderByName_pargs args;
  args.request = &request;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_GetHeaderByName(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_GetHeaderByName") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_GetHeaderByName_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetHeaderByName failed: unknown result");
}

void ServerClient::Request_SetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name, const std::string& value, const bool overwrite)
{
  send_Request_SetHeaderByName(request, name, value, overwrite);
  recv_Request_SetHeaderByName();
}

void ServerClient::send_Request_SetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_SetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetHeaderByName_pargs args;
  args.request = &request;
  args.name = &name;
  args.value = &value;
  args.overwrite = &overwrite;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_SetHeaderByName()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_SetHeaderByName") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_SetHeaderByName_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Request_GetHeaderMap(std::map<std::string, std::string> & _return, const  ::thrift_codegen::RObject& request)
{
  send_Request_GetHeaderMap(request);
  recv_Request_GetHeaderMap(_return);
}

void ServerClient::send_Request_GetHeaderMap(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_GetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetHeaderMap_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_GetHeaderMap(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_GetHeaderMap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_GetHeaderMap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetHeaderMap failed: unknown result");
}

void ServerClient::Request_SetHeaderMap(const  ::thrift_codegen::RObject& request, const std::map<std::string, std::string> & headerMap)
{
  send_Request_SetHeaderMap(request, headerMap);
  recv_Request_SetHeaderMap();
}

void ServerClient::send_Request_SetHeaderMap(const  ::thrift_codegen::RObject& request, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_SetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetHeaderMap_pargs args;
  args.request = &request;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_SetHeaderMap()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_SetHeaderMap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_SetHeaderMap_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Request_Set(const  ::thrift_codegen::RObject& request, const std::string& url, const std::string& method, const  ::thrift_codegen::PostData& postData, const std::map<std::string, std::string> & headerMap)
{
  send_Request_Set(request, url, method, postData, headerMap);
  recv_Request_Set();
}

void ServerClient::send_Request_Set(const  ::thrift_codegen::RObject& request, const std::string& url, const std::string& method, const  ::thrift_codegen::PostData& postData, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Request_Set", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_Set_pargs args;
  args.request = &request;
  args.url = &url;
  args.method = &method;
  args.postData = &postData;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Request_Set()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Request_Set") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Request_Set_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Response_Update(const  ::thrift_codegen::RObject& response)
{
  send_Response_Update(response);
  recv_Response_Update();
}

void ServerClient::send_Response_Update(const  ::thrift_codegen::RObject& response)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Response_Update", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_Update_pargs args;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Response_Update()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Response_Update") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Response_Update_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Response_GetHeaderByName(std::string& _return, const  ::thrift_codegen::RObject& response, const std::string& name)
{
  send_Response_GetHeaderByName(response, name);
  recv_Response_GetHeaderByName(_return);
}

void ServerClient::send_Response_GetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Response_GetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_GetHeaderByName_pargs args;
  args.response = &response;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Response_GetHeaderByName(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Response_GetHeaderByName") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Response_GetHeaderByName_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Response_GetHeaderByName failed: unknown result");
}

void ServerClient::Response_SetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name, const std::string& value, const bool overwrite)
{
  send_Response_SetHeaderByName(response, name, value, overwrite);
  recv_Response_SetHeaderByName();
}

void ServerClient::send_Response_SetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Response_SetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_SetHeaderByName_pargs args;
  args.response = &response;
  args.name = &name;
  args.value = &value;
  args.overwrite = &overwrite;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Response_SetHeaderByName()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Response_SetHeaderByName") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Response_SetHeaderByName_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Response_GetHeaderMap(std::map<std::string, std::string> & _return, const  ::thrift_codegen::RObject& response)
{
  send_Response_GetHeaderMap(response);
  recv_Response_GetHeaderMap(_return);
}

void ServerClient::send_Response_GetHeaderMap(const  ::thrift_codegen::RObject& response)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Response_GetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_GetHeaderMap_pargs args;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Response_GetHeaderMap(std::map<std::string, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Response_GetHeaderMap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Response_GetHeaderMap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Response_GetHeaderMap failed: unknown result");
}

void ServerClient::Response_SetHeaderMap(const  ::thrift_codegen::RObject& response, const std::map<std::string, std::string> & headerMap)
{
  send_Response_SetHeaderMap(response, headerMap);
  recv_Response_SetHeaderMap();
}

void ServerClient::send_Response_SetHeaderMap(const  ::thrift_codegen::RObject& response, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Response_SetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_SetHeaderMap_pargs args;
  args.response = &response;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_Response_SetHeaderMap()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Response_SetHeaderMap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_Response_SetHeaderMap_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::Callback_Dispose(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Dispose(callback);
}

void ServerClient::send_Callback_Dispose(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Callback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Dispose_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Callback_Continue(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Continue(callback);
}

void ServerClient::send_Callback_Continue(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Callback_Continue", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Continue_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::Callback_Cancel(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Cancel(callback);
}

void ServerClient::send_Callback_Cancel(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Callback_Cancel", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Cancel_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::AuthCallback_Dispose(const  ::thrift_codegen::RObject& authCallback)
{
  send_AuthCallback_Dispose(authCallback);
}

void ServerClient::send_AuthCallback_Dispose(const  ::thrift_codegen::RObject& authCallback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("AuthCallback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Dispose_pargs args;
  args.authCallback = &authCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::AuthCallback_Continue(const  ::thrift_codegen::RObject& authCallback, const std::string& username, const std::string& password)
{
  send_AuthCallback_Continue(authCallback, username, password);
}

void ServerClient::send_AuthCallback_Continue(const  ::thrift_codegen::RObject& authCallback, const std::string& username, const std::string& password)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("AuthCallback_Continue", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Continue_pargs args;
  args.authCallback = &authCallback;
  args.username = &username;
  args.password = &password;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::AuthCallback_Cancel(const  ::thrift_codegen::RObject& authCallback)
{
  send_AuthCallback_Cancel(authCallback);
}

void ServerClient::send_AuthCallback_Cancel(const  ::thrift_codegen::RObject& authCallback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("AuthCallback_Cancel", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Cancel_pargs args;
  args.authCallback = &authCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::MessageRouter_Create( ::thrift_codegen::RObject& _return, const std::string& query, const std::string& cancel)
{
  send_MessageRouter_Create(query, cancel);
  recv_MessageRouter_Create(_return);
}

void ServerClient::send_MessageRouter_Create(const std::string& query, const std::string& cancel)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_Create", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_Create_pargs args;
  args.query = &query;
  args.cancel = &cancel;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_Create( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_Create") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_Create_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MessageRouter_Create failed: unknown result");
}

void ServerClient::MessageRouter_Dispose(const  ::thrift_codegen::RObject& msgRouter)
{
  send_MessageRouter_Dispose(msgRouter);
}

void ServerClient::send_MessageRouter_Dispose(const  ::thrift_codegen::RObject& msgRouter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_MessageRouter_Dispose_pargs args;
  args.msgRouter = &msgRouter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::MessageRouter_AddMessageRouterToBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  send_MessageRouter_AddMessageRouterToBrowser(msgRouter, bid);
  recv_MessageRouter_AddMessageRouterToBrowser();
}

void ServerClient::send_MessageRouter_AddMessageRouterToBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_AddMessageRouterToBrowser", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_AddMessageRouterToBrowser_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_AddMessageRouterToBrowser()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_AddMessageRouterToBrowser") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_AddMessageRouterToBrowser_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::MessageRouter_RemoveMessageRouterFromBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  send_MessageRouter_RemoveMessageRouterFromBrowser(msgRouter, bid);
  recv_MessageRouter_RemoveMessageRouterFromBrowser();
}

void ServerClient::send_MessageRouter_RemoveMessageRouterFromBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_RemoveMessageRouterFromBrowser", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_RemoveMessageRouterFromBrowser()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_RemoveMessageRouterFromBrowser") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_RemoveMessageRouterFromBrowser_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::MessageRouter_AddHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler, const bool first)
{
  send_MessageRouter_AddHandler(msgRouter, handler, first);
  recv_MessageRouter_AddHandler();
}

void ServerClient::send_MessageRouter_AddHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler, const bool first)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_AddHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_AddHandler_pargs args;
  args.msgRouter = &msgRouter;
  args.handler = &handler;
  args.first = &first;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_AddHandler()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_AddHandler") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_AddHandler_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::MessageRouter_RemoveHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler)
{
  send_MessageRouter_RemoveHandler(msgRouter, handler);
  recv_MessageRouter_RemoveHandler();
}

void ServerClient::send_MessageRouter_RemoveHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_RemoveHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_RemoveHandler_pargs args;
  args.msgRouter = &msgRouter;
  args.handler = &handler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_RemoveHandler()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_RemoveHandler") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_RemoveHandler_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::MessageRouter_CancelPending(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid, const  ::thrift_codegen::RObject& handler)
{
  send_MessageRouter_CancelPending(msgRouter, bid, handler);
  recv_MessageRouter_CancelPending();
}

void ServerClient::send_MessageRouter_CancelPending(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid, const  ::thrift_codegen::RObject& handler)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouter_CancelPending", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_CancelPending_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.handler = &handler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::recv_MessageRouter_CancelPending()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouter_CancelPending") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Server_MessageRouter_CancelPending_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ServerClient::QueryCallback_Dispose(const  ::thrift_codegen::RObject& qcallback)
{
  send_QueryCallback_Dispose(qcallback);
}

void ServerClient::send_QueryCallback_Dispose(const  ::thrift_codegen::RObject& qcallback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QueryCallback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Dispose_pargs args;
  args.qcallback = &qcallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::QueryCallback_Success(const  ::thrift_codegen::RObject& qcallback, const std::string& response)
{
  send_QueryCallback_Success(qcallback, response);
}

void ServerClient::send_QueryCallback_Success(const  ::thrift_codegen::RObject& qcallback, const std::string& response)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QueryCallback_Success", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Success_pargs args;
  args.qcallback = &qcallback;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ServerClient::QueryCallback_Failure(const  ::thrift_codegen::RObject& qcallback, const int32_t error_code, const std::string& error_message)
{
  send_QueryCallback_Failure(qcallback, error_code, error_message);
}

void ServerClient::send_QueryCallback_Failure(const  ::thrift_codegen::RObject& qcallback, const int32_t error_code, const std::string& error_message)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QueryCallback_Failure", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Failure_pargs args;
  args.qcallback = &qcallback;
  args.error_code = &error_code;
  args.error_message = &error_message;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ServerProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void ServerProcessor::process_connect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.connect", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.connect");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.connect");
  }

  Server_connect_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.connect", bytes);
  }

  Server_connect_result result;
  try {
    result.success = iface_->connect(args.backwardConnectionPort, args.cmdLineArgs, args.settings);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.connect");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("connect", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.connect");
  }

  oprot->writeMessageBegin("connect", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.connect", bytes);
  }
}

void ServerProcessor::process_log(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.log", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.log");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.log");
  }

  Server_log_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.log", bytes);
  }

  try {
    iface_->log(args.msg);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.log");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.log");
  }

  return;
}

void ServerProcessor::process_createBrowser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.createBrowser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.createBrowser");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.createBrowser");
  }

  Server_createBrowser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.createBrowser", bytes);
  }

  Server_createBrowser_result result;
  try {
    result.success = iface_->createBrowser(args.cid, args.url);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.createBrowser");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("createBrowser", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.createBrowser");
  }

  oprot->writeMessageBegin("createBrowser", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.createBrowser", bytes);
  }
}

void ServerProcessor::process_closeBrowser(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.closeBrowser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.closeBrowser");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.closeBrowser");
  }

  Server_closeBrowser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.closeBrowser", bytes);
  }

  try {
    iface_->closeBrowser(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.closeBrowser");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.closeBrowser");
  }

  return;
}

void ServerProcessor::process_Browser_Reload(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_Reload", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_Reload");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_Reload");
  }

  Server_Browser_Reload_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_Reload", bytes);
  }

  try {
    iface_->Browser_Reload(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_Reload");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_Reload");
  }

  return;
}

void ServerProcessor::process_Browser_ReloadIgnoreCache(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_ReloadIgnoreCache", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_ReloadIgnoreCache");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_ReloadIgnoreCache");
  }

  Server_Browser_ReloadIgnoreCache_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_ReloadIgnoreCache", bytes);
  }

  try {
    iface_->Browser_ReloadIgnoreCache(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_ReloadIgnoreCache");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_ReloadIgnoreCache");
  }

  return;
}

void ServerProcessor::process_Browser_LoadURL(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_LoadURL", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_LoadURL");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_LoadURL");
  }

  Server_Browser_LoadURL_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_LoadURL", bytes);
  }

  try {
    iface_->Browser_LoadURL(args.bid, args.url);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_LoadURL");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_LoadURL");
  }

  return;
}

void ServerProcessor::process_Browser_GetURL(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_GetURL", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_GetURL");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_GetURL");
  }

  Server_Browser_GetURL_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_GetURL", bytes);
  }

  Server_Browser_GetURL_result result;
  try {
    iface_->Browser_GetURL(result.success, args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_GetURL");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Browser_GetURL", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Browser_GetURL");
  }

  oprot->writeMessageBegin("Browser_GetURL", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Browser_GetURL", bytes);
  }
}

void ServerProcessor::process_Browser_ExecuteJavaScript(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_ExecuteJavaScript", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_ExecuteJavaScript");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_ExecuteJavaScript");
  }

  Server_Browser_ExecuteJavaScript_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_ExecuteJavaScript", bytes);
  }

  try {
    iface_->Browser_ExecuteJavaScript(args.bid, args.code, args.url, args.line);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_ExecuteJavaScript");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_ExecuteJavaScript");
  }

  return;
}

void ServerProcessor::process_Browser_WasResized(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_WasResized", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_WasResized");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_WasResized");
  }

  Server_Browser_WasResized_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_WasResized", bytes);
  }

  try {
    iface_->Browser_WasResized(args.bid, args.width, args.height);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_WasResized");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_WasResized");
  }

  return;
}

void ServerProcessor::process_Browser_SendKeyEvent(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_SendKeyEvent", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_SendKeyEvent");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_SendKeyEvent");
  }

  Server_Browser_SendKeyEvent_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_SendKeyEvent", bytes);
  }

  try {
    iface_->Browser_SendKeyEvent(args.bid, args.event_type, args.modifiers, args.key_char, args.scanCode, args.key_code);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_SendKeyEvent");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_SendKeyEvent");
  }

  return;
}

void ServerProcessor::process_Browser_SendMouseEvent(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_SendMouseEvent", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_SendMouseEvent");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_SendMouseEvent");
  }

  Server_Browser_SendMouseEvent_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_SendMouseEvent", bytes);
  }

  try {
    iface_->Browser_SendMouseEvent(args.bid, args.event_type, args.x, args.y, args.modifiers, args.click_count, args.button);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_SendMouseEvent");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_SendMouseEvent");
  }

  return;
}

void ServerProcessor::process_Browser_SendMouseWheelEvent(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Browser_SendMouseWheelEvent", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Browser_SendMouseWheelEvent");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Browser_SendMouseWheelEvent");
  }

  Server_Browser_SendMouseWheelEvent_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Browser_SendMouseWheelEvent", bytes);
  }

  try {
    iface_->Browser_SendMouseWheelEvent(args.bid, args.scroll_type, args.x, args.y, args.modifiers, args.delta, args.units_to_scroll);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Browser_SendMouseWheelEvent");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Browser_SendMouseWheelEvent");
  }

  return;
}

void ServerProcessor::process_Request_Update(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_Update", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_Update");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_Update");
  }

  Server_Request_Update_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_Update", bytes);
  }

  Server_Request_Update_result result;
  try {
    iface_->Request_Update(args.request);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_Update");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_Update", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_Update");
  }

  oprot->writeMessageBegin("Request_Update", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_Update", bytes);
  }
}

void ServerProcessor::process_Request_GetPostData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_GetPostData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_GetPostData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_GetPostData");
  }

  Server_Request_GetPostData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_GetPostData", bytes);
  }

  Server_Request_GetPostData_result result;
  try {
    iface_->Request_GetPostData(result.success, args.request);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_GetPostData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_GetPostData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_GetPostData");
  }

  oprot->writeMessageBegin("Request_GetPostData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_GetPostData", bytes);
  }
}

void ServerProcessor::process_Request_SetPostData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_SetPostData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_SetPostData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_SetPostData");
  }

  Server_Request_SetPostData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_SetPostData", bytes);
  }

  Server_Request_SetPostData_result result;
  try {
    iface_->Request_SetPostData(args.request, args.postData);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_SetPostData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_SetPostData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_SetPostData");
  }

  oprot->writeMessageBegin("Request_SetPostData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_SetPostData", bytes);
  }
}

void ServerProcessor::process_Request_GetHeaderByName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_GetHeaderByName", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_GetHeaderByName");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_GetHeaderByName");
  }

  Server_Request_GetHeaderByName_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_GetHeaderByName", bytes);
  }

  Server_Request_GetHeaderByName_result result;
  try {
    iface_->Request_GetHeaderByName(result.success, args.request, args.name);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_GetHeaderByName");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_GetHeaderByName", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_GetHeaderByName");
  }

  oprot->writeMessageBegin("Request_GetHeaderByName", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_GetHeaderByName", bytes);
  }
}

void ServerProcessor::process_Request_SetHeaderByName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_SetHeaderByName", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_SetHeaderByName");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_SetHeaderByName");
  }

  Server_Request_SetHeaderByName_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_SetHeaderByName", bytes);
  }

  Server_Request_SetHeaderByName_result result;
  try {
    iface_->Request_SetHeaderByName(args.request, args.name, args.value, args.overwrite);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_SetHeaderByName");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_SetHeaderByName", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_SetHeaderByName");
  }

  oprot->writeMessageBegin("Request_SetHeaderByName", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_SetHeaderByName", bytes);
  }
}

void ServerProcessor::process_Request_GetHeaderMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_GetHeaderMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_GetHeaderMap");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_GetHeaderMap");
  }

  Server_Request_GetHeaderMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_GetHeaderMap", bytes);
  }

  Server_Request_GetHeaderMap_result result;
  try {
    iface_->Request_GetHeaderMap(result.success, args.request);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_GetHeaderMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_GetHeaderMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_GetHeaderMap");
  }

  oprot->writeMessageBegin("Request_GetHeaderMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_GetHeaderMap", bytes);
  }
}

void ServerProcessor::process_Request_SetHeaderMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_SetHeaderMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_SetHeaderMap");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_SetHeaderMap");
  }

  Server_Request_SetHeaderMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_SetHeaderMap", bytes);
  }

  Server_Request_SetHeaderMap_result result;
  try {
    iface_->Request_SetHeaderMap(args.request, args.headerMap);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_SetHeaderMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_SetHeaderMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_SetHeaderMap");
  }

  oprot->writeMessageBegin("Request_SetHeaderMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_SetHeaderMap", bytes);
  }
}

void ServerProcessor::process_Request_Set(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Request_Set", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Request_Set");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Request_Set");
  }

  Server_Request_Set_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Request_Set", bytes);
  }

  Server_Request_Set_result result;
  try {
    iface_->Request_Set(args.request, args.url, args.method, args.postData, args.headerMap);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Request_Set");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Request_Set", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Request_Set");
  }

  oprot->writeMessageBegin("Request_Set", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Request_Set", bytes);
  }
}

void ServerProcessor::process_Response_Update(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Response_Update", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Response_Update");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Response_Update");
  }

  Server_Response_Update_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Response_Update", bytes);
  }

  Server_Response_Update_result result;
  try {
    iface_->Response_Update(args.response);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Response_Update");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Response_Update", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Response_Update");
  }

  oprot->writeMessageBegin("Response_Update", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Response_Update", bytes);
  }
}

void ServerProcessor::process_Response_GetHeaderByName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Response_GetHeaderByName", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Response_GetHeaderByName");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Response_GetHeaderByName");
  }

  Server_Response_GetHeaderByName_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Response_GetHeaderByName", bytes);
  }

  Server_Response_GetHeaderByName_result result;
  try {
    iface_->Response_GetHeaderByName(result.success, args.response, args.name);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Response_GetHeaderByName");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Response_GetHeaderByName", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Response_GetHeaderByName");
  }

  oprot->writeMessageBegin("Response_GetHeaderByName", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Response_GetHeaderByName", bytes);
  }
}

void ServerProcessor::process_Response_SetHeaderByName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Response_SetHeaderByName", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Response_SetHeaderByName");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Response_SetHeaderByName");
  }

  Server_Response_SetHeaderByName_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Response_SetHeaderByName", bytes);
  }

  Server_Response_SetHeaderByName_result result;
  try {
    iface_->Response_SetHeaderByName(args.response, args.name, args.value, args.overwrite);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Response_SetHeaderByName");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Response_SetHeaderByName", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Response_SetHeaderByName");
  }

  oprot->writeMessageBegin("Response_SetHeaderByName", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Response_SetHeaderByName", bytes);
  }
}

void ServerProcessor::process_Response_GetHeaderMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Response_GetHeaderMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Response_GetHeaderMap");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Response_GetHeaderMap");
  }

  Server_Response_GetHeaderMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Response_GetHeaderMap", bytes);
  }

  Server_Response_GetHeaderMap_result result;
  try {
    iface_->Response_GetHeaderMap(result.success, args.response);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Response_GetHeaderMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Response_GetHeaderMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Response_GetHeaderMap");
  }

  oprot->writeMessageBegin("Response_GetHeaderMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Response_GetHeaderMap", bytes);
  }
}

void ServerProcessor::process_Response_SetHeaderMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Response_SetHeaderMap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Response_SetHeaderMap");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Response_SetHeaderMap");
  }

  Server_Response_SetHeaderMap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Response_SetHeaderMap", bytes);
  }

  Server_Response_SetHeaderMap_result result;
  try {
    iface_->Response_SetHeaderMap(args.response, args.headerMap);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Response_SetHeaderMap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Response_SetHeaderMap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.Response_SetHeaderMap");
  }

  oprot->writeMessageBegin("Response_SetHeaderMap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.Response_SetHeaderMap", bytes);
  }
}

void ServerProcessor::process_Callback_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Callback_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Callback_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Callback_Dispose");
  }

  Server_Callback_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Callback_Dispose", bytes);
  }

  try {
    iface_->Callback_Dispose(args.callback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Callback_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Callback_Dispose");
  }

  return;
}

void ServerProcessor::process_Callback_Continue(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Callback_Continue", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Callback_Continue");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Callback_Continue");
  }

  Server_Callback_Continue_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Callback_Continue", bytes);
  }

  try {
    iface_->Callback_Continue(args.callback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Callback_Continue");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Callback_Continue");
  }

  return;
}

void ServerProcessor::process_Callback_Cancel(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.Callback_Cancel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.Callback_Cancel");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.Callback_Cancel");
  }

  Server_Callback_Cancel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.Callback_Cancel", bytes);
  }

  try {
    iface_->Callback_Cancel(args.callback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.Callback_Cancel");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.Callback_Cancel");
  }

  return;
}

void ServerProcessor::process_AuthCallback_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.AuthCallback_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.AuthCallback_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.AuthCallback_Dispose");
  }

  Server_AuthCallback_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.AuthCallback_Dispose", bytes);
  }

  try {
    iface_->AuthCallback_Dispose(args.authCallback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.AuthCallback_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.AuthCallback_Dispose");
  }

  return;
}

void ServerProcessor::process_AuthCallback_Continue(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.AuthCallback_Continue", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.AuthCallback_Continue");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.AuthCallback_Continue");
  }

  Server_AuthCallback_Continue_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.AuthCallback_Continue", bytes);
  }

  try {
    iface_->AuthCallback_Continue(args.authCallback, args.username, args.password);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.AuthCallback_Continue");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.AuthCallback_Continue");
  }

  return;
}

void ServerProcessor::process_AuthCallback_Cancel(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.AuthCallback_Cancel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.AuthCallback_Cancel");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.AuthCallback_Cancel");
  }

  Server_AuthCallback_Cancel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.AuthCallback_Cancel", bytes);
  }

  try {
    iface_->AuthCallback_Cancel(args.authCallback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.AuthCallback_Cancel");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.AuthCallback_Cancel");
  }

  return;
}

void ServerProcessor::process_MessageRouter_Create(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_Create", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_Create");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_Create");
  }

  Server_MessageRouter_Create_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_Create", bytes);
  }

  Server_MessageRouter_Create_result result;
  try {
    iface_->MessageRouter_Create(result.success, args.query, args.cancel);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_Create");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_Create", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_Create");
  }

  oprot->writeMessageBegin("MessageRouter_Create", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_Create", bytes);
  }
}

void ServerProcessor::process_MessageRouter_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_Dispose");
  }

  Server_MessageRouter_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_Dispose", bytes);
  }

  try {
    iface_->MessageRouter_Dispose(args.msgRouter);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.MessageRouter_Dispose");
  }

  return;
}

void ServerProcessor::process_MessageRouter_AddMessageRouterToBrowser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_AddMessageRouterToBrowser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_AddMessageRouterToBrowser");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_AddMessageRouterToBrowser");
  }

  Server_MessageRouter_AddMessageRouterToBrowser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_AddMessageRouterToBrowser", bytes);
  }

  Server_MessageRouter_AddMessageRouterToBrowser_result result;
  try {
    iface_->MessageRouter_AddMessageRouterToBrowser(args.msgRouter, args.bid);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_AddMessageRouterToBrowser");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_AddMessageRouterToBrowser", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_AddMessageRouterToBrowser");
  }

  oprot->writeMessageBegin("MessageRouter_AddMessageRouterToBrowser", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_AddMessageRouterToBrowser", bytes);
  }
}

void ServerProcessor::process_MessageRouter_RemoveMessageRouterFromBrowser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_RemoveMessageRouterFromBrowser", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser");
  }

  Server_MessageRouter_RemoveMessageRouterFromBrowser_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser", bytes);
  }

  Server_MessageRouter_RemoveMessageRouterFromBrowser_result result;
  try {
    iface_->MessageRouter_RemoveMessageRouterFromBrowser(args.msgRouter, args.bid);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_RemoveMessageRouterFromBrowser", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser");
  }

  oprot->writeMessageBegin("MessageRouter_RemoveMessageRouterFromBrowser", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_RemoveMessageRouterFromBrowser", bytes);
  }
}

void ServerProcessor::process_MessageRouter_AddHandler(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_AddHandler", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_AddHandler");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_AddHandler");
  }

  Server_MessageRouter_AddHandler_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_AddHandler", bytes);
  }

  Server_MessageRouter_AddHandler_result result;
  try {
    iface_->MessageRouter_AddHandler(args.msgRouter, args.handler, args.first);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_AddHandler");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_AddHandler", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_AddHandler");
  }

  oprot->writeMessageBegin("MessageRouter_AddHandler", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_AddHandler", bytes);
  }
}

void ServerProcessor::process_MessageRouter_RemoveHandler(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_RemoveHandler", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_RemoveHandler");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_RemoveHandler");
  }

  Server_MessageRouter_RemoveHandler_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_RemoveHandler", bytes);
  }

  Server_MessageRouter_RemoveHandler_result result;
  try {
    iface_->MessageRouter_RemoveHandler(args.msgRouter, args.handler);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_RemoveHandler");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_RemoveHandler", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_RemoveHandler");
  }

  oprot->writeMessageBegin("MessageRouter_RemoveHandler", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_RemoveHandler", bytes);
  }
}

void ServerProcessor::process_MessageRouter_CancelPending(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.MessageRouter_CancelPending", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.MessageRouter_CancelPending");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.MessageRouter_CancelPending");
  }

  Server_MessageRouter_CancelPending_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.MessageRouter_CancelPending", bytes);
  }

  Server_MessageRouter_CancelPending_result result;
  try {
    iface_->MessageRouter_CancelPending(args.msgRouter, args.bid, args.handler);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.MessageRouter_CancelPending");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouter_CancelPending", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "Server.MessageRouter_CancelPending");
  }

  oprot->writeMessageBegin("MessageRouter_CancelPending", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "Server.MessageRouter_CancelPending", bytes);
  }
}

void ServerProcessor::process_QueryCallback_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.QueryCallback_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.QueryCallback_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.QueryCallback_Dispose");
  }

  Server_QueryCallback_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.QueryCallback_Dispose", bytes);
  }

  try {
    iface_->QueryCallback_Dispose(args.qcallback);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.QueryCallback_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.QueryCallback_Dispose");
  }

  return;
}

void ServerProcessor::process_QueryCallback_Success(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.QueryCallback_Success", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.QueryCallback_Success");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.QueryCallback_Success");
  }

  Server_QueryCallback_Success_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.QueryCallback_Success", bytes);
  }

  try {
    iface_->QueryCallback_Success(args.qcallback, args.response);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.QueryCallback_Success");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.QueryCallback_Success");
  }

  return;
}

void ServerProcessor::process_QueryCallback_Failure(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("Server.QueryCallback_Failure", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Server.QueryCallback_Failure");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "Server.QueryCallback_Failure");
  }

  Server_QueryCallback_Failure_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "Server.QueryCallback_Failure", bytes);
  }

  try {
    iface_->QueryCallback_Failure(args.qcallback, args.error_code, args.error_message);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "Server.QueryCallback_Failure");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "Server.QueryCallback_Failure");
  }

  return;
}

::std::shared_ptr< ::apache::thrift::TProcessor > ServerProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< ServerIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< ServerIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new ServerProcessor(handler));
  return processor;
}

int32_t ServerConcurrentClient::connect(const int32_t backwardConnectionPort, const std::vector<std::string> & cmdLineArgs, const std::map<std::string, std::string> & settings)
{
  int32_t seqid = send_connect(backwardConnectionPort, cmdLineArgs, settings);
  return recv_connect(seqid);
}

int32_t ServerConcurrentClient::send_connect(const int32_t backwardConnectionPort, const std::vector<std::string> & cmdLineArgs, const std::map<std::string, std::string> & settings)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("connect", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_connect_pargs args;
  args.backwardConnectionPort = &backwardConnectionPort;
  args.cmdLineArgs = &cmdLineArgs;
  args.settings = &settings;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t ServerConcurrentClient::recv_connect(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("connect") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      Server_connect_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connect failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::log(const std::string& msg)
{
  send_log(msg);
}

void ServerConcurrentClient::send_log(const std::string& msg)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("log", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_log_pargs args;
  args.msg = &msg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

int32_t ServerConcurrentClient::createBrowser(const int32_t cid, const std::string& url)
{
  int32_t seqid = send_createBrowser(cid, url);
  return recv_createBrowser(seqid);
}

int32_t ServerConcurrentClient::send_createBrowser(const int32_t cid, const std::string& url)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("createBrowser", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_createBrowser_pargs args;
  args.cid = &cid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t ServerConcurrentClient::recv_createBrowser(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("createBrowser") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      Server_createBrowser_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "createBrowser failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::closeBrowser(const int32_t bid)
{
  send_closeBrowser(bid);
}

void ServerConcurrentClient::send_closeBrowser(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("closeBrowser", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_closeBrowser_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_Reload(const int32_t bid)
{
  send_Browser_Reload(bid);
}

void ServerConcurrentClient::send_Browser_Reload(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_Reload", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_Reload_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_ReloadIgnoreCache(const int32_t bid)
{
  send_Browser_ReloadIgnoreCache(bid);
}

void ServerConcurrentClient::send_Browser_ReloadIgnoreCache(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_ReloadIgnoreCache", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ReloadIgnoreCache_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_LoadURL(const int32_t bid, const std::string& url)
{
  send_Browser_LoadURL(bid, url);
}

void ServerConcurrentClient::send_Browser_LoadURL(const int32_t bid, const std::string& url)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_LoadURL", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_LoadURL_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_GetURL(std::string& _return, const int32_t bid)
{
  int32_t seqid = send_Browser_GetURL(bid);
  recv_Browser_GetURL(_return, seqid);
}

int32_t ServerConcurrentClient::send_Browser_GetURL(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_GetURL", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Browser_GetURL_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Browser_GetURL(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Browser_GetURL") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Browser_GetURL_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Browser_GetURL failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Browser_ExecuteJavaScript(const int32_t bid, const std::string& code, const std::string& url, const int32_t line)
{
  send_Browser_ExecuteJavaScript(bid, code, url, line);
}

void ServerConcurrentClient::send_Browser_ExecuteJavaScript(const int32_t bid, const std::string& code, const std::string& url, const int32_t line)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_ExecuteJavaScript", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_ExecuteJavaScript_pargs args;
  args.bid = &bid;
  args.code = &code;
  args.url = &url;
  args.line = &line;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_WasResized(const int32_t bid, const int32_t width, const int32_t height)
{
  send_Browser_WasResized(bid, width, height);
}

void ServerConcurrentClient::send_Browser_WasResized(const int32_t bid, const int32_t width, const int32_t height)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_WasResized", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_WasResized_pargs args;
  args.bid = &bid;
  args.width = &width;
  args.height = &height;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_SendKeyEvent(const int32_t bid, const int32_t event_type, const int32_t modifiers, const int16_t key_char, const int64_t scanCode, const int32_t key_code)
{
  send_Browser_SendKeyEvent(bid, event_type, modifiers, key_char, scanCode, key_code);
}

void ServerConcurrentClient::send_Browser_SendKeyEvent(const int32_t bid, const int32_t event_type, const int32_t modifiers, const int16_t key_char, const int64_t scanCode, const int32_t key_code)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_SendKeyEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendKeyEvent_pargs args;
  args.bid = &bid;
  args.event_type = &event_type;
  args.modifiers = &modifiers;
  args.key_char = &key_char;
  args.scanCode = &scanCode;
  args.key_code = &key_code;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_SendMouseEvent(const int32_t bid, const int32_t event_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t click_count, const int32_t button)
{
  send_Browser_SendMouseEvent(bid, event_type, x, y, modifiers, click_count, button);
}

void ServerConcurrentClient::send_Browser_SendMouseEvent(const int32_t bid, const int32_t event_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t click_count, const int32_t button)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_SendMouseEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendMouseEvent_pargs args;
  args.bid = &bid;
  args.event_type = &event_type;
  args.x = &x;
  args.y = &y;
  args.modifiers = &modifiers;
  args.click_count = &click_count;
  args.button = &button;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Browser_SendMouseWheelEvent(const int32_t bid, const int32_t scroll_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t delta, const int32_t units_to_scroll)
{
  send_Browser_SendMouseWheelEvent(bid, scroll_type, x, y, modifiers, delta, units_to_scroll);
}

void ServerConcurrentClient::send_Browser_SendMouseWheelEvent(const int32_t bid, const int32_t scroll_type, const int32_t x, const int32_t y, const int32_t modifiers, const int32_t delta, const int32_t units_to_scroll)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Browser_SendMouseWheelEvent", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Browser_SendMouseWheelEvent_pargs args;
  args.bid = &bid;
  args.scroll_type = &scroll_type;
  args.x = &x;
  args.y = &y;
  args.modifiers = &modifiers;
  args.delta = &delta;
  args.units_to_scroll = &units_to_scroll;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Request_Update(const  ::thrift_codegen::RObject& request)
{
  int32_t seqid = send_Request_Update(request);
  recv_Request_Update(seqid);
}

int32_t ServerConcurrentClient::send_Request_Update(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_Update", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_Update_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_Update(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_Update") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_Update_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_GetPostData( ::thrift_codegen::PostData& _return, const  ::thrift_codegen::RObject& request)
{
  int32_t seqid = send_Request_GetPostData(request);
  recv_Request_GetPostData(_return, seqid);
}

int32_t ServerConcurrentClient::send_Request_GetPostData(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_GetPostData", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetPostData_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_GetPostData( ::thrift_codegen::PostData& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_GetPostData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_GetPostData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetPostData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_SetPostData(const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::PostData& postData)
{
  int32_t seqid = send_Request_SetPostData(request, postData);
  recv_Request_SetPostData(seqid);
}

int32_t ServerConcurrentClient::send_Request_SetPostData(const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::PostData& postData)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_SetPostData", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetPostData_pargs args;
  args.request = &request;
  args.postData = &postData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_SetPostData(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_SetPostData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_SetPostData_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_GetHeaderByName(std::string& _return, const  ::thrift_codegen::RObject& request, const std::string& name)
{
  int32_t seqid = send_Request_GetHeaderByName(request, name);
  recv_Request_GetHeaderByName(_return, seqid);
}

int32_t ServerConcurrentClient::send_Request_GetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_GetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetHeaderByName_pargs args;
  args.request = &request;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_GetHeaderByName(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_GetHeaderByName") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_GetHeaderByName_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetHeaderByName failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_SetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t seqid = send_Request_SetHeaderByName(request, name, value, overwrite);
  recv_Request_SetHeaderByName(seqid);
}

int32_t ServerConcurrentClient::send_Request_SetHeaderByName(const  ::thrift_codegen::RObject& request, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_SetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetHeaderByName_pargs args;
  args.request = &request;
  args.name = &name;
  args.value = &value;
  args.overwrite = &overwrite;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_SetHeaderByName(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_SetHeaderByName") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_SetHeaderByName_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_GetHeaderMap(std::map<std::string, std::string> & _return, const  ::thrift_codegen::RObject& request)
{
  int32_t seqid = send_Request_GetHeaderMap(request);
  recv_Request_GetHeaderMap(_return, seqid);
}

int32_t ServerConcurrentClient::send_Request_GetHeaderMap(const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_GetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_GetHeaderMap_pargs args;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_GetHeaderMap(std::map<std::string, std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_GetHeaderMap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_GetHeaderMap_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Request_GetHeaderMap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_SetHeaderMap(const  ::thrift_codegen::RObject& request, const std::map<std::string, std::string> & headerMap)
{
  int32_t seqid = send_Request_SetHeaderMap(request, headerMap);
  recv_Request_SetHeaderMap(seqid);
}

int32_t ServerConcurrentClient::send_Request_SetHeaderMap(const  ::thrift_codegen::RObject& request, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_SetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_SetHeaderMap_pargs args;
  args.request = &request;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_SetHeaderMap(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_SetHeaderMap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_SetHeaderMap_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Request_Set(const  ::thrift_codegen::RObject& request, const std::string& url, const std::string& method, const  ::thrift_codegen::PostData& postData, const std::map<std::string, std::string> & headerMap)
{
  int32_t seqid = send_Request_Set(request, url, method, postData, headerMap);
  recv_Request_Set(seqid);
}

int32_t ServerConcurrentClient::send_Request_Set(const  ::thrift_codegen::RObject& request, const std::string& url, const std::string& method, const  ::thrift_codegen::PostData& postData, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Request_Set", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Request_Set_pargs args;
  args.request = &request;
  args.url = &url;
  args.method = &method;
  args.postData = &postData;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Request_Set(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Request_Set") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Request_Set_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Response_Update(const  ::thrift_codegen::RObject& response)
{
  int32_t seqid = send_Response_Update(response);
  recv_Response_Update(seqid);
}

int32_t ServerConcurrentClient::send_Response_Update(const  ::thrift_codegen::RObject& response)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Response_Update", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_Update_pargs args;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Response_Update(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Response_Update") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Response_Update_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Response_GetHeaderByName(std::string& _return, const  ::thrift_codegen::RObject& response, const std::string& name)
{
  int32_t seqid = send_Response_GetHeaderByName(response, name);
  recv_Response_GetHeaderByName(_return, seqid);
}

int32_t ServerConcurrentClient::send_Response_GetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Response_GetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_GetHeaderByName_pargs args;
  args.response = &response;
  args.name = &name;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Response_GetHeaderByName(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Response_GetHeaderByName") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Response_GetHeaderByName_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Response_GetHeaderByName failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Response_SetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t seqid = send_Response_SetHeaderByName(response, name, value, overwrite);
  recv_Response_SetHeaderByName(seqid);
}

int32_t ServerConcurrentClient::send_Response_SetHeaderByName(const  ::thrift_codegen::RObject& response, const std::string& name, const std::string& value, const bool overwrite)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Response_SetHeaderByName", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_SetHeaderByName_pargs args;
  args.response = &response;
  args.name = &name;
  args.value = &value;
  args.overwrite = &overwrite;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Response_SetHeaderByName(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Response_SetHeaderByName") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Response_SetHeaderByName_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Response_GetHeaderMap(std::map<std::string, std::string> & _return, const  ::thrift_codegen::RObject& response)
{
  int32_t seqid = send_Response_GetHeaderMap(response);
  recv_Response_GetHeaderMap(_return, seqid);
}

int32_t ServerConcurrentClient::send_Response_GetHeaderMap(const  ::thrift_codegen::RObject& response)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Response_GetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_GetHeaderMap_pargs args;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Response_GetHeaderMap(std::map<std::string, std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Response_GetHeaderMap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Response_GetHeaderMap_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Response_GetHeaderMap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Response_SetHeaderMap(const  ::thrift_codegen::RObject& response, const std::map<std::string, std::string> & headerMap)
{
  int32_t seqid = send_Response_SetHeaderMap(response, headerMap);
  recv_Response_SetHeaderMap(seqid);
}

int32_t ServerConcurrentClient::send_Response_SetHeaderMap(const  ::thrift_codegen::RObject& response, const std::map<std::string, std::string> & headerMap)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Response_SetHeaderMap", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_Response_SetHeaderMap_pargs args;
  args.response = &response;
  args.headerMap = &headerMap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_Response_SetHeaderMap(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Response_SetHeaderMap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_Response_SetHeaderMap_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::Callback_Dispose(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Dispose(callback);
}

void ServerConcurrentClient::send_Callback_Dispose(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Callback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Dispose_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Callback_Continue(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Continue(callback);
}

void ServerConcurrentClient::send_Callback_Continue(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Callback_Continue", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Continue_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::Callback_Cancel(const  ::thrift_codegen::RObject& callback)
{
  send_Callback_Cancel(callback);
}

void ServerConcurrentClient::send_Callback_Cancel(const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Callback_Cancel", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_Callback_Cancel_pargs args;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::AuthCallback_Dispose(const  ::thrift_codegen::RObject& authCallback)
{
  send_AuthCallback_Dispose(authCallback);
}

void ServerConcurrentClient::send_AuthCallback_Dispose(const  ::thrift_codegen::RObject& authCallback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("AuthCallback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Dispose_pargs args;
  args.authCallback = &authCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::AuthCallback_Continue(const  ::thrift_codegen::RObject& authCallback, const std::string& username, const std::string& password)
{
  send_AuthCallback_Continue(authCallback, username, password);
}

void ServerConcurrentClient::send_AuthCallback_Continue(const  ::thrift_codegen::RObject& authCallback, const std::string& username, const std::string& password)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("AuthCallback_Continue", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Continue_pargs args;
  args.authCallback = &authCallback;
  args.username = &username;
  args.password = &password;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::AuthCallback_Cancel(const  ::thrift_codegen::RObject& authCallback)
{
  send_AuthCallback_Cancel(authCallback);
}

void ServerConcurrentClient::send_AuthCallback_Cancel(const  ::thrift_codegen::RObject& authCallback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("AuthCallback_Cancel", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_AuthCallback_Cancel_pargs args;
  args.authCallback = &authCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::MessageRouter_Create( ::thrift_codegen::RObject& _return, const std::string& query, const std::string& cancel)
{
  int32_t seqid = send_MessageRouter_Create(query, cancel);
  recv_MessageRouter_Create(_return, seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_Create(const std::string& query, const std::string& cancel)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_Create", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_Create_pargs args;
  args.query = &query;
  args.cancel = &cancel;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_Create( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_Create") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_Create_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MessageRouter_Create failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::MessageRouter_Dispose(const  ::thrift_codegen::RObject& msgRouter)
{
  send_MessageRouter_Dispose(msgRouter);
}

void ServerConcurrentClient::send_MessageRouter_Dispose(const  ::thrift_codegen::RObject& msgRouter)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_MessageRouter_Dispose_pargs args;
  args.msgRouter = &msgRouter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::MessageRouter_AddMessageRouterToBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t seqid = send_MessageRouter_AddMessageRouterToBrowser(msgRouter, bid);
  recv_MessageRouter_AddMessageRouterToBrowser(seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_AddMessageRouterToBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_AddMessageRouterToBrowser", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_AddMessageRouterToBrowser_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_AddMessageRouterToBrowser(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_AddMessageRouterToBrowser") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_AddMessageRouterToBrowser_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::MessageRouter_RemoveMessageRouterFromBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t seqid = send_MessageRouter_RemoveMessageRouterFromBrowser(msgRouter, bid);
  recv_MessageRouter_RemoveMessageRouterFromBrowser(seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_RemoveMessageRouterFromBrowser(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_RemoveMessageRouterFromBrowser", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_RemoveMessageRouterFromBrowser_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_RemoveMessageRouterFromBrowser(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_RemoveMessageRouterFromBrowser") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_RemoveMessageRouterFromBrowser_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::MessageRouter_AddHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler, const bool first)
{
  int32_t seqid = send_MessageRouter_AddHandler(msgRouter, handler, first);
  recv_MessageRouter_AddHandler(seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_AddHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler, const bool first)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_AddHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_AddHandler_pargs args;
  args.msgRouter = &msgRouter;
  args.handler = &handler;
  args.first = &first;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_AddHandler(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_AddHandler") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_AddHandler_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::MessageRouter_RemoveHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler)
{
  int32_t seqid = send_MessageRouter_RemoveHandler(msgRouter, handler);
  recv_MessageRouter_RemoveHandler(seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_RemoveHandler(const  ::thrift_codegen::RObject& msgRouter, const  ::thrift_codegen::RObject& handler)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_RemoveHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_RemoveHandler_pargs args;
  args.msgRouter = &msgRouter;
  args.handler = &handler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_RemoveHandler(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_RemoveHandler") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_RemoveHandler_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::MessageRouter_CancelPending(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid, const  ::thrift_codegen::RObject& handler)
{
  int32_t seqid = send_MessageRouter_CancelPending(msgRouter, bid, handler);
  recv_MessageRouter_CancelPending(seqid);
}

int32_t ServerConcurrentClient::send_MessageRouter_CancelPending(const  ::thrift_codegen::RObject& msgRouter, const int32_t bid, const  ::thrift_codegen::RObject& handler)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouter_CancelPending", ::apache::thrift::protocol::T_CALL, cseqid);

  Server_MessageRouter_CancelPending_pargs args;
  args.msgRouter = &msgRouter;
  args.bid = &bid;
  args.handler = &handler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ServerConcurrentClient::recv_MessageRouter_CancelPending(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouter_CancelPending") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Server_MessageRouter_CancelPending_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ServerConcurrentClient::QueryCallback_Dispose(const  ::thrift_codegen::RObject& qcallback)
{
  send_QueryCallback_Dispose(qcallback);
}

void ServerConcurrentClient::send_QueryCallback_Dispose(const  ::thrift_codegen::RObject& qcallback)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QueryCallback_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Dispose_pargs args;
  args.qcallback = &qcallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::QueryCallback_Success(const  ::thrift_codegen::RObject& qcallback, const std::string& response)
{
  send_QueryCallback_Success(qcallback, response);
}

void ServerConcurrentClient::send_QueryCallback_Success(const  ::thrift_codegen::RObject& qcallback, const std::string& response)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QueryCallback_Success", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Success_pargs args;
  args.qcallback = &qcallback;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ServerConcurrentClient::QueryCallback_Failure(const  ::thrift_codegen::RObject& qcallback, const int32_t error_code, const std::string& error_message)
{
  send_QueryCallback_Failure(qcallback, error_code, error_message);
}

void ServerConcurrentClient::send_QueryCallback_Failure(const  ::thrift_codegen::RObject& qcallback, const int32_t error_code, const std::string& error_message)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QueryCallback_Failure", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Server_QueryCallback_Failure_pargs args;
  args.qcallback = &qcallback;
  args.error_code = &error_code;
  args.error_message = &error_message;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

} // namespace

