/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ClientHandlers.h"

namespace thrift_codegen {


ClientHandlers_connect_args::~ClientHandlers_connect_args() noexcept {
}


uint32_t ClientHandlers_connect_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_connect_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_connect_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_connect_pargs::~ClientHandlers_connect_pargs() noexcept {
}


uint32_t ClientHandlers_connect_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_connect_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_connect_result::~ClientHandlers_connect_result() noexcept {
}


uint32_t ClientHandlers_connect_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_connect_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_connect_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_connect_presult::~ClientHandlers_connect_presult() noexcept {
}


uint32_t ClientHandlers_connect_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_log_args::~ClientHandlers_log_args() noexcept {
}


uint32_t ClientHandlers_log_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_log_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_log_args");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_log_pargs::~ClientHandlers_log_pargs() noexcept {
}


uint32_t ClientHandlers_log_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_log_pargs");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->msg)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_AppHandler_GetRegisteredCustomSchemes_args::~ClientHandlers_AppHandler_GetRegisteredCustomSchemes_args() noexcept {
}


uint32_t ClientHandlers_AppHandler_GetRegisteredCustomSchemes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_AppHandler_GetRegisteredCustomSchemes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_AppHandler_GetRegisteredCustomSchemes_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_AppHandler_GetRegisteredCustomSchemes_pargs::~ClientHandlers_AppHandler_GetRegisteredCustomSchemes_pargs() noexcept {
}


uint32_t ClientHandlers_AppHandler_GetRegisteredCustomSchemes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_AppHandler_GetRegisteredCustomSchemes_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_AppHandler_GetRegisteredCustomSchemes_result::~ClientHandlers_AppHandler_GetRegisteredCustomSchemes_result() noexcept {
}


uint32_t ClientHandlers_AppHandler_GetRegisteredCustomSchemes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->success.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->success[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_AppHandler_GetRegisteredCustomSchemes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_AppHandler_GetRegisteredCustomSchemes_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<CustomScheme> ::const_iterator _iter13;
      for (_iter13 = this->success.begin(); _iter13 != this->success.end(); ++_iter13)
      {
        xfer += (*_iter13).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_AppHandler_GetRegisteredCustomSchemes_presult::~ClientHandlers_AppHandler_GetRegisteredCustomSchemes_presult() noexcept {
}


uint32_t ClientHandlers_AppHandler_GetRegisteredCustomSchemes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            (*(this->success)).resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += (*(this->success))[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_AppHandler_OnContextInitialized_args::~ClientHandlers_AppHandler_OnContextInitialized_args() noexcept {
}


uint32_t ClientHandlers_AppHandler_OnContextInitialized_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_AppHandler_OnContextInitialized_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_AppHandler_OnContextInitialized_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_AppHandler_OnContextInitialized_pargs::~ClientHandlers_AppHandler_OnContextInitialized_pargs() noexcept {
}


uint32_t ClientHandlers_AppHandler_OnContextInitialized_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_AppHandler_OnContextInitialized_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_AppHandler_OnContextInitialized_result::~ClientHandlers_AppHandler_OnContextInitialized_result() noexcept {
}


uint32_t ClientHandlers_AppHandler_OnContextInitialized_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_AppHandler_OnContextInitialized_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_AppHandler_OnContextInitialized_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_AppHandler_OnContextInitialized_presult::~ClientHandlers_AppHandler_OnContextInitialized_presult() noexcept {
}


uint32_t ClientHandlers_AppHandler_OnContextInitialized_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_RenderHandler_GetViewRect_args::~ClientHandlers_RenderHandler_GetViewRect_args() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetViewRect_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RenderHandler_GetViewRect_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_GetViewRect_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_GetViewRect_pargs::~ClientHandlers_RenderHandler_GetViewRect_pargs() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetViewRect_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_GetViewRect_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_GetViewRect_result::~ClientHandlers_RenderHandler_GetViewRect_result() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetViewRect_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RenderHandler_GetViewRect_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_GetViewRect_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_GetViewRect_presult::~ClientHandlers_RenderHandler_GetViewRect_presult() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetViewRect_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_RenderHandler_GetScreenInfo_args::~ClientHandlers_RenderHandler_GetScreenInfo_args() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetScreenInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RenderHandler_GetScreenInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_GetScreenInfo_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_GetScreenInfo_pargs::~ClientHandlers_RenderHandler_GetScreenInfo_pargs() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetScreenInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_GetScreenInfo_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_GetScreenInfo_result::~ClientHandlers_RenderHandler_GetScreenInfo_result() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetScreenInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RenderHandler_GetScreenInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_GetScreenInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_GetScreenInfo_presult::~ClientHandlers_RenderHandler_GetScreenInfo_presult() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetScreenInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_RenderHandler_GetScreenPoint_args::~ClientHandlers_RenderHandler_GetScreenPoint_args() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetScreenPoint_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->viewX);
          this->__isset.viewX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->viewY);
          this->__isset.viewY = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RenderHandler_GetScreenPoint_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_GetScreenPoint_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewX", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->viewX);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewY", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->viewY);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_GetScreenPoint_pargs::~ClientHandlers_RenderHandler_GetScreenPoint_pargs() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetScreenPoint_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_GetScreenPoint_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewX", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->viewX)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewY", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->viewY)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_GetScreenPoint_result::~ClientHandlers_RenderHandler_GetScreenPoint_result() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetScreenPoint_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RenderHandler_GetScreenPoint_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_GetScreenPoint_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_GetScreenPoint_presult::~ClientHandlers_RenderHandler_GetScreenPoint_presult() noexcept {
}


uint32_t ClientHandlers_RenderHandler_GetScreenPoint_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_RenderHandler_OnPaint_args::~ClientHandlers_RenderHandler_OnPaint_args() noexcept {
}


uint32_t ClientHandlers_RenderHandler_OnPaint_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->popup);
          this->__isset.popup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dirtyRectsCount);
          this->__isset.dirtyRectsCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sharedMemName);
          this->__isset.sharedMemName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sharedMemHandle);
          this->__isset.sharedMemHandle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RenderHandler_OnPaint_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_OnPaint_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("popup", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->popup);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dirtyRectsCount", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->dirtyRectsCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharedMemName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->sharedMemName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharedMemHandle", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->sharedMemHandle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_OnPaint_pargs::~ClientHandlers_RenderHandler_OnPaint_pargs() noexcept {
}


uint32_t ClientHandlers_RenderHandler_OnPaint_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_OnPaint_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("popup", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->popup)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dirtyRectsCount", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->dirtyRectsCount)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharedMemName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->sharedMemName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sharedMemHandle", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->sharedMemHandle)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->width)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((*(this->height)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_OnPaint_result::~ClientHandlers_RenderHandler_OnPaint_result() noexcept {
}


uint32_t ClientHandlers_RenderHandler_OnPaint_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RenderHandler_OnPaint_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_RenderHandler_OnPaint_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RenderHandler_OnPaint_presult::~ClientHandlers_RenderHandler_OnPaint_presult() noexcept {
}


uint32_t ClientHandlers_RenderHandler_OnPaint_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_LifeSpanHandler_OnBeforePopup_args::~ClientHandlers_LifeSpanHandler_OnBeforePopup_args() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_OnBeforePopup_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->frameName);
          this->__isset.frameName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->gesture);
          this->__isset.gesture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_LifeSpanHandler_OnBeforePopup_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LifeSpanHandler_OnBeforePopup_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("frameName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->frameName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gesture", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->gesture);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LifeSpanHandler_OnBeforePopup_pargs::~ClientHandlers_LifeSpanHandler_OnBeforePopup_pargs() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_OnBeforePopup_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LifeSpanHandler_OnBeforePopup_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("frameName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->frameName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gesture", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->gesture)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LifeSpanHandler_OnBeforePopup_result::~ClientHandlers_LifeSpanHandler_OnBeforePopup_result() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_OnBeforePopup_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_LifeSpanHandler_OnBeforePopup_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_LifeSpanHandler_OnBeforePopup_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LifeSpanHandler_OnBeforePopup_presult::~ClientHandlers_LifeSpanHandler_OnBeforePopup_presult() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_OnBeforePopup_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_LifeSpanHandler_OnAfterCreated_args::~ClientHandlers_LifeSpanHandler_OnAfterCreated_args() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_OnAfterCreated_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_LifeSpanHandler_OnAfterCreated_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LifeSpanHandler_OnAfterCreated_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LifeSpanHandler_OnAfterCreated_pargs::~ClientHandlers_LifeSpanHandler_OnAfterCreated_pargs() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_OnAfterCreated_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LifeSpanHandler_OnAfterCreated_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LifeSpanHandler_DoClose_args::~ClientHandlers_LifeSpanHandler_DoClose_args() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_DoClose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_LifeSpanHandler_DoClose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LifeSpanHandler_DoClose_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LifeSpanHandler_DoClose_pargs::~ClientHandlers_LifeSpanHandler_DoClose_pargs() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_DoClose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LifeSpanHandler_DoClose_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LifeSpanHandler_DoClose_result::~ClientHandlers_LifeSpanHandler_DoClose_result() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_DoClose_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_LifeSpanHandler_DoClose_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_LifeSpanHandler_DoClose_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LifeSpanHandler_DoClose_presult::~ClientHandlers_LifeSpanHandler_DoClose_presult() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_DoClose_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_LifeSpanHandler_OnBeforeClose_args::~ClientHandlers_LifeSpanHandler_OnBeforeClose_args() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_OnBeforeClose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_LifeSpanHandler_OnBeforeClose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LifeSpanHandler_OnBeforeClose_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LifeSpanHandler_OnBeforeClose_pargs::~ClientHandlers_LifeSpanHandler_OnBeforeClose_pargs() noexcept {
}


uint32_t ClientHandlers_LifeSpanHandler_OnBeforeClose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LifeSpanHandler_OnBeforeClose_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LoadHandler_OnLoadingStateChange_args::~ClientHandlers_LoadHandler_OnLoadingStateChange_args() noexcept {
}


uint32_t ClientHandlers_LoadHandler_OnLoadingStateChange_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isLoading);
          this->__isset.isLoading = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->canGoBack);
          this->__isset.canGoBack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->canGoForward);
          this->__isset.canGoForward = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_LoadHandler_OnLoadingStateChange_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LoadHandler_OnLoadingStateChange_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isLoading", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isLoading);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("canGoBack", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->canGoBack);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("canGoForward", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->canGoForward);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LoadHandler_OnLoadingStateChange_pargs::~ClientHandlers_LoadHandler_OnLoadingStateChange_pargs() noexcept {
}


uint32_t ClientHandlers_LoadHandler_OnLoadingStateChange_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LoadHandler_OnLoadingStateChange_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isLoading", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->isLoading)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("canGoBack", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->canGoBack)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("canGoForward", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->canGoForward)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LoadHandler_OnLoadStart_args::~ClientHandlers_LoadHandler_OnLoadStart_args() noexcept {
}


uint32_t ClientHandlers_LoadHandler_OnLoadStart_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transition_type);
          this->__isset.transition_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_LoadHandler_OnLoadStart_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LoadHandler_OnLoadStart_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transition_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->transition_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LoadHandler_OnLoadStart_pargs::~ClientHandlers_LoadHandler_OnLoadStart_pargs() noexcept {
}


uint32_t ClientHandlers_LoadHandler_OnLoadStart_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LoadHandler_OnLoadStart_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transition_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->transition_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LoadHandler_OnLoadEnd_args::~ClientHandlers_LoadHandler_OnLoadEnd_args() noexcept {
}


uint32_t ClientHandlers_LoadHandler_OnLoadEnd_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->httpStatusCode);
          this->__isset.httpStatusCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_LoadHandler_OnLoadEnd_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LoadHandler_OnLoadEnd_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("httpStatusCode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->httpStatusCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LoadHandler_OnLoadEnd_pargs::~ClientHandlers_LoadHandler_OnLoadEnd_pargs() noexcept {
}


uint32_t ClientHandlers_LoadHandler_OnLoadEnd_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LoadHandler_OnLoadEnd_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("httpStatusCode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->httpStatusCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LoadHandler_OnLoadError_args::~ClientHandlers_LoadHandler_OnLoadError_args() noexcept {
}


uint32_t ClientHandlers_LoadHandler_OnLoadError_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errorText);
          this->__isset.errorText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->failedUrl);
          this->__isset.failedUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_LoadHandler_OnLoadError_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LoadHandler_OnLoadError_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->errorCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errorText", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->errorText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failedUrl", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->failedUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_LoadHandler_OnLoadError_pargs::~ClientHandlers_LoadHandler_OnLoadError_pargs() noexcept {
}


uint32_t ClientHandlers_LoadHandler_OnLoadError_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_LoadHandler_OnLoadError_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->errorCode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errorText", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->errorText)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failedUrl", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->failedUrl)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnAddressChange_args::~ClientHandlers_DisplayHandler_OnAddressChange_args() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnAddressChange_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_DisplayHandler_OnAddressChange_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnAddressChange_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnAddressChange_pargs::~ClientHandlers_DisplayHandler_OnAddressChange_pargs() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnAddressChange_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnAddressChange_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnTitleChange_args::~ClientHandlers_DisplayHandler_OnTitleChange_args() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnTitleChange_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_DisplayHandler_OnTitleChange_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnTitleChange_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnTitleChange_pargs::~ClientHandlers_DisplayHandler_OnTitleChange_pargs() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnTitleChange_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnTitleChange_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->title)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnTooltip_args::~ClientHandlers_DisplayHandler_OnTooltip_args() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnTooltip_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_DisplayHandler_OnTooltip_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnTooltip_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnTooltip_pargs::~ClientHandlers_DisplayHandler_OnTooltip_pargs() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnTooltip_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnTooltip_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->text)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnTooltip_result::~ClientHandlers_DisplayHandler_OnTooltip_result() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnTooltip_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_DisplayHandler_OnTooltip_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnTooltip_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnTooltip_presult::~ClientHandlers_DisplayHandler_OnTooltip_presult() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnTooltip_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_DisplayHandler_OnStatusMessage_args::~ClientHandlers_DisplayHandler_OnStatusMessage_args() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnStatusMessage_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_DisplayHandler_OnStatusMessage_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnStatusMessage_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnStatusMessage_pargs::~ClientHandlers_DisplayHandler_OnStatusMessage_pargs() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnStatusMessage_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnStatusMessage_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnConsoleMessage_args::~ClientHandlers_DisplayHandler_OnConsoleMessage_args() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnConsoleMessage_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->line);
          this->__isset.line = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_DisplayHandler_OnConsoleMessage_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnConsoleMessage_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->source);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->line);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnConsoleMessage_pargs::~ClientHandlers_DisplayHandler_OnConsoleMessage_pargs() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnConsoleMessage_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnConsoleMessage_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->level)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->message)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->source)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->line)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnConsoleMessage_result::~ClientHandlers_DisplayHandler_OnConsoleMessage_result() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnConsoleMessage_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_DisplayHandler_OnConsoleMessage_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_DisplayHandler_OnConsoleMessage_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_DisplayHandler_OnConsoleMessage_presult::~ClientHandlers_DisplayHandler_OnConsoleMessage_presult() noexcept {
}


uint32_t ClientHandlers_DisplayHandler_OnConsoleMessage_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_RequestHandler_OnBeforeBrowse_args::~ClientHandlers_RequestHandler_OnBeforeBrowse_args() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnBeforeBrowse_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->user_gesture);
          this->__isset.user_gesture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_redirect);
          this->__isset.is_redirect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RequestHandler_OnBeforeBrowse_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_OnBeforeBrowse_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user_gesture", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->user_gesture);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_redirect", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_redirect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_OnBeforeBrowse_pargs::~ClientHandlers_RequestHandler_OnBeforeBrowse_pargs() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnBeforeBrowse_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_OnBeforeBrowse_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user_gesture", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->user_gesture)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_redirect", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->is_redirect)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_OnBeforeBrowse_result::~ClientHandlers_RequestHandler_OnBeforeBrowse_result() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnBeforeBrowse_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RequestHandler_OnBeforeBrowse_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_OnBeforeBrowse_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_OnBeforeBrowse_presult::~ClientHandlers_RequestHandler_OnBeforeBrowse_presult() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnBeforeBrowse_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_RequestHandler_OnOpenURLFromTab_args::~ClientHandlers_RequestHandler_OnOpenURLFromTab_args() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnOpenURLFromTab_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_url);
          this->__isset.target_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->user_gesture);
          this->__isset.user_gesture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RequestHandler_OnOpenURLFromTab_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_OnOpenURLFromTab_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->target_url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user_gesture", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->user_gesture);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_OnOpenURLFromTab_pargs::~ClientHandlers_RequestHandler_OnOpenURLFromTab_pargs() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnOpenURLFromTab_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_OnOpenURLFromTab_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->target_url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user_gesture", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->user_gesture)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_OnOpenURLFromTab_result::~ClientHandlers_RequestHandler_OnOpenURLFromTab_result() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnOpenURLFromTab_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RequestHandler_OnOpenURLFromTab_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_OnOpenURLFromTab_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_OnOpenURLFromTab_presult::~ClientHandlers_RequestHandler_OnOpenURLFromTab_presult() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnOpenURLFromTab_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_RequestHandler_GetAuthCredentials_args::~ClientHandlers_RequestHandler_GetAuthCredentials_args() noexcept {
}


uint32_t ClientHandlers_RequestHandler_GetAuthCredentials_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->origin_url);
          this->__isset.origin_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isProxy);
          this->__isset.isProxy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->realm);
          this->__isset.realm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scheme);
          this->__isset.scheme = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authCallback.read(iprot);
          this->__isset.authCallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RequestHandler_GetAuthCredentials_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_GetAuthCredentials_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin_url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->origin_url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isProxy", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isProxy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("realm", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->realm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scheme", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->scheme);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->authCallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_GetAuthCredentials_pargs::~ClientHandlers_RequestHandler_GetAuthCredentials_pargs() noexcept {
}


uint32_t ClientHandlers_RequestHandler_GetAuthCredentials_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_GetAuthCredentials_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("origin_url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->origin_url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isProxy", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->isProxy)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->host)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->port)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("realm", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString((*(this->realm)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scheme", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString((*(this->scheme)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authCallback", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += (*(this->authCallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_GetAuthCredentials_result::~ClientHandlers_RequestHandler_GetAuthCredentials_result() noexcept {
}


uint32_t ClientHandlers_RequestHandler_GetAuthCredentials_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RequestHandler_GetAuthCredentials_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_GetAuthCredentials_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_GetAuthCredentials_presult::~ClientHandlers_RequestHandler_GetAuthCredentials_presult() noexcept {
}


uint32_t ClientHandlers_RequestHandler_GetAuthCredentials_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_RequestHandler_OnCertificateError_args::~ClientHandlers_RequestHandler_OnCertificateError_args() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnCertificateError_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cert_error);
          this->__isset.cert_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->request_url);
          this->__isset.request_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sslInfo.read(iprot);
          this->__isset.sslInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->callback.read(iprot);
          this->__isset.callback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RequestHandler_OnCertificateError_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_OnCertificateError_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cert_error", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->cert_error);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request_url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->request_url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sslInfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->sslInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->callback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_OnCertificateError_pargs::~ClientHandlers_RequestHandler_OnCertificateError_pargs() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnCertificateError_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_OnCertificateError_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cert_error", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->cert_error)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request_url", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->request_url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sslInfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->sslInfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("callback", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += (*(this->callback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_OnCertificateError_result::~ClientHandlers_RequestHandler_OnCertificateError_result() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnCertificateError_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RequestHandler_OnCertificateError_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_OnCertificateError_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_OnCertificateError_presult::~ClientHandlers_RequestHandler_OnCertificateError_presult() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnCertificateError_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_RequestHandler_OnRenderProcessTerminated_args::~ClientHandlers_RequestHandler_OnRenderProcessTerminated_args() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnRenderProcessTerminated_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RequestHandler_OnRenderProcessTerminated_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_OnRenderProcessTerminated_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_OnRenderProcessTerminated_pargs::~ClientHandlers_RequestHandler_OnRenderProcessTerminated_pargs() noexcept {
}


uint32_t ClientHandlers_RequestHandler_OnRenderProcessTerminated_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_OnRenderProcessTerminated_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->status)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_GetResourceRequestHandler_args::~ClientHandlers_RequestHandler_GetResourceRequestHandler_args() noexcept {
}


uint32_t ClientHandlers_RequestHandler_GetResourceRequestHandler_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isNavigation);
          this->__isset.isNavigation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isDownload);
          this->__isset.isDownload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->requestInitiator);
          this->__isset.requestInitiator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RequestHandler_GetResourceRequestHandler_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_GetResourceRequestHandler_args");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isNavigation", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isNavigation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isDownload", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->isDownload);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requestInitiator", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->requestInitiator);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_GetResourceRequestHandler_pargs::~ClientHandlers_RequestHandler_GetResourceRequestHandler_pargs() noexcept {
}


uint32_t ClientHandlers_RequestHandler_GetResourceRequestHandler_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_GetResourceRequestHandler_pargs");

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isNavigation", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->isNavigation)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isDownload", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->isDownload)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requestInitiator", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->requestInitiator)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_GetResourceRequestHandler_result::~ClientHandlers_RequestHandler_GetResourceRequestHandler_result() noexcept {
}


uint32_t ClientHandlers_RequestHandler_GetResourceRequestHandler_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_RequestHandler_GetResourceRequestHandler_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_RequestHandler_GetResourceRequestHandler_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_RequestHandler_GetResourceRequestHandler_presult::~ClientHandlers_RequestHandler_GetResourceRequestHandler_presult() noexcept {
}


uint32_t ClientHandlers_RequestHandler_GetResourceRequestHandler_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_ResourceRequestHandler_Dispose_args::~ClientHandlers_ResourceRequestHandler_Dispose_args() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rrHandler);
          this->__isset.rrHandler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_Dispose_args");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rrHandler);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_Dispose_pargs::~ClientHandlers_ResourceRequestHandler_Dispose_pargs() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_Dispose_pargs");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rrHandler)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_args::~ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_args() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rrHandler);
          this->__isset.rrHandler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_args");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rrHandler);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_pargs::~ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_pargs() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_pargs");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rrHandler)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_result::~ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_result() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_presult::~ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_presult() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_CookieAccessFilter_Dispose_args::~ClientHandlers_CookieAccessFilter_Dispose_args() noexcept {
}


uint32_t ClientHandlers_CookieAccessFilter_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->filter);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_CookieAccessFilter_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_CookieAccessFilter_Dispose_args");

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_CookieAccessFilter_Dispose_pargs::~ClientHandlers_CookieAccessFilter_Dispose_pargs() noexcept {
}


uint32_t ClientHandlers_CookieAccessFilter_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_CookieAccessFilter_Dispose_pargs");

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->filter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_CookieAccessFilter_CanSendCookie_args::~ClientHandlers_CookieAccessFilter_CanSendCookie_args() noexcept {
}


uint32_t ClientHandlers_CookieAccessFilter_CanSendCookie_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->filter);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cookie.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->cookie.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += iprot->readString(this->cookie[_i23]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cookie = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_CookieAccessFilter_CanSendCookie_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_CookieAccessFilter_CanSendCookie_args");

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookie", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cookie.size()));
    std::vector<std::string> ::const_iterator _iter24;
    for (_iter24 = this->cookie.begin(); _iter24 != this->cookie.end(); ++_iter24)
    {
      xfer += oprot->writeString((*_iter24));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_CookieAccessFilter_CanSendCookie_pargs::~ClientHandlers_CookieAccessFilter_CanSendCookie_pargs() noexcept {
}


uint32_t ClientHandlers_CookieAccessFilter_CanSendCookie_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_CookieAccessFilter_CanSendCookie_pargs");

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->filter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookie", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->cookie)).size()));
    std::vector<std::string> ::const_iterator _iter25;
    for (_iter25 = (*(this->cookie)).begin(); _iter25 != (*(this->cookie)).end(); ++_iter25)
    {
      xfer += oprot->writeString((*_iter25));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_CookieAccessFilter_CanSendCookie_result::~ClientHandlers_CookieAccessFilter_CanSendCookie_result() noexcept {
}


uint32_t ClientHandlers_CookieAccessFilter_CanSendCookie_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_CookieAccessFilter_CanSendCookie_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_CookieAccessFilter_CanSendCookie_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_CookieAccessFilter_CanSendCookie_presult::~ClientHandlers_CookieAccessFilter_CanSendCookie_presult() noexcept {
}


uint32_t ClientHandlers_CookieAccessFilter_CanSendCookie_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_CookieAccessFilter_CanSaveCookie_args::~ClientHandlers_CookieAccessFilter_CanSaveCookie_args() noexcept {
}


uint32_t ClientHandlers_CookieAccessFilter_CanSaveCookie_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->filter);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cookie.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->cookie.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += iprot->readString(this->cookie[_i30]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cookie = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_CookieAccessFilter_CanSaveCookie_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_CookieAccessFilter_CanSaveCookie_args");

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookie", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cookie.size()));
    std::vector<std::string> ::const_iterator _iter31;
    for (_iter31 = this->cookie.begin(); _iter31 != this->cookie.end(); ++_iter31)
    {
      xfer += oprot->writeString((*_iter31));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_CookieAccessFilter_CanSaveCookie_pargs::~ClientHandlers_CookieAccessFilter_CanSaveCookie_pargs() noexcept {
}


uint32_t ClientHandlers_CookieAccessFilter_CanSaveCookie_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_CookieAccessFilter_CanSaveCookie_pargs");

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->filter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookie", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->cookie)).size()));
    std::vector<std::string> ::const_iterator _iter32;
    for (_iter32 = (*(this->cookie)).begin(); _iter32 != (*(this->cookie)).end(); ++_iter32)
    {
      xfer += oprot->writeString((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_CookieAccessFilter_CanSaveCookie_result::~ClientHandlers_CookieAccessFilter_CanSaveCookie_result() noexcept {
}


uint32_t ClientHandlers_CookieAccessFilter_CanSaveCookie_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_CookieAccessFilter_CanSaveCookie_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_CookieAccessFilter_CanSaveCookie_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_CookieAccessFilter_CanSaveCookie_presult::~ClientHandlers_CookieAccessFilter_CanSaveCookie_presult() noexcept {
}


uint32_t ClientHandlers_CookieAccessFilter_CanSaveCookie_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_args::~ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_args() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rrHandler);
          this->__isset.rrHandler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_args");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rrHandler);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_pargs::~ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_pargs() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_pargs");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rrHandler)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_result::~ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_result() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_presult::~ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_presult() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_ResourceRequestHandler_GetResourceHandler_args::~ClientHandlers_ResourceRequestHandler_GetResourceHandler_args() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_GetResourceHandler_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rrHandler);
          this->__isset.rrHandler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_GetResourceHandler_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_GetResourceHandler_args");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rrHandler);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_GetResourceHandler_pargs::~ClientHandlers_ResourceRequestHandler_GetResourceHandler_pargs() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_GetResourceHandler_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_GetResourceHandler_pargs");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rrHandler)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_GetResourceHandler_result::~ClientHandlers_ResourceRequestHandler_GetResourceHandler_result() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_GetResourceHandler_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_GetResourceHandler_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_GetResourceHandler_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_GetResourceHandler_presult::~ClientHandlers_ResourceRequestHandler_GetResourceHandler_presult() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_GetResourceHandler_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_ResourceHandler_Dispose_args::~ClientHandlers_ResourceHandler_Dispose_args() noexcept {
}


uint32_t ClientHandlers_ResourceHandler_Dispose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->resourceHandler);
          this->__isset.resourceHandler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceHandler_Dispose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceHandler_Dispose_args");

  xfer += oprot->writeFieldBegin("resourceHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->resourceHandler);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceHandler_Dispose_pargs::~ClientHandlers_ResourceHandler_Dispose_pargs() noexcept {
}


uint32_t ClientHandlers_ResourceHandler_Dispose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceHandler_Dispose_pargs");

  xfer += oprot->writeFieldBegin("resourceHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->resourceHandler)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnResourceRedirect_args::~ClientHandlers_ResourceRequestHandler_OnResourceRedirect_args() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnResourceRedirect_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rrHandler);
          this->__isset.rrHandler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->new_url);
          this->__isset.new_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_OnResourceRedirect_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnResourceRedirect_args");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rrHandler);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_url", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->new_url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnResourceRedirect_pargs::~ClientHandlers_ResourceRequestHandler_OnResourceRedirect_pargs() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnResourceRedirect_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnResourceRedirect_pargs");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rrHandler)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_url", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->new_url)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnResourceRedirect_result::~ClientHandlers_ResourceRequestHandler_OnResourceRedirect_result() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnResourceRedirect_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_OnResourceRedirect_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnResourceRedirect_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnResourceRedirect_presult::~ClientHandlers_ResourceRequestHandler_OnResourceRedirect_presult() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnResourceRedirect_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnResourceResponse_args::~ClientHandlers_ResourceRequestHandler_OnResourceResponse_args() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnResourceResponse_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rrHandler);
          this->__isset.rrHandler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_OnResourceResponse_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnResourceResponse_args");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rrHandler);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnResourceResponse_pargs::~ClientHandlers_ResourceRequestHandler_OnResourceResponse_pargs() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnResourceResponse_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnResourceResponse_pargs");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rrHandler)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnResourceResponse_result::~ClientHandlers_ResourceRequestHandler_OnResourceResponse_result() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnResourceResponse_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_OnResourceResponse_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnResourceResponse_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnResourceResponse_presult::~ClientHandlers_ResourceRequestHandler_OnResourceResponse_presult() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnResourceResponse_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_args::~ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_args() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rrHandler);
          this->__isset.rrHandler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->response.read(iprot);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->receivedContentLength);
          this->__isset.receivedContentLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_args");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rrHandler);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->response.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("receivedContentLength", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->receivedContentLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_pargs::~ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_pargs() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_pargs");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rrHandler)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->response)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->status)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("receivedContentLength", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64((*(this->receivedContentLength)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnProtocolExecution_args::~ClientHandlers_ResourceRequestHandler_OnProtocolExecution_args() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnProtocolExecution_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rrHandler);
          this->__isset.rrHandler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->allowOsExecution);
          this->__isset.allowOsExecution = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_OnProtocolExecution_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnProtocolExecution_args");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->rrHandler);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allowOsExecution", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->allowOsExecution);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnProtocolExecution_pargs::~ClientHandlers_ResourceRequestHandler_OnProtocolExecution_pargs() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnProtocolExecution_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnProtocolExecution_pargs");

  xfer += oprot->writeFieldBegin("rrHandler", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->rrHandler)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->request)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allowOsExecution", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->allowOsExecution)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnProtocolExecution_result::~ClientHandlers_ResourceRequestHandler_OnProtocolExecution_result() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnProtocolExecution_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_ResourceRequestHandler_OnProtocolExecution_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_ResourceRequestHandler_OnProtocolExecution_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_ResourceRequestHandler_OnProtocolExecution_presult::~ClientHandlers_ResourceRequestHandler_OnProtocolExecution_presult() noexcept {
}


uint32_t ClientHandlers_ResourceRequestHandler_OnProtocolExecution_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_MessageRouterHandler_onQuery_args::~ClientHandlers_MessageRouterHandler_onQuery_args() noexcept {
}


uint32_t ClientHandlers_MessageRouterHandler_onQuery_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->handler.read(iprot);
          this->__isset.handler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          this->__isset.queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->request);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->persistent);
          this->__isset.persistent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->queryCallback.read(iprot);
          this->__isset.queryCallback = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_MessageRouterHandler_onQuery_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_MessageRouterHandler_onQuery_args");

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->handler.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->request);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("persistent", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->persistent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryCallback", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->queryCallback.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_MessageRouterHandler_onQuery_pargs::~ClientHandlers_MessageRouterHandler_onQuery_pargs() noexcept {
}


uint32_t ClientHandlers_MessageRouterHandler_onQuery_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_MessageRouterHandler_onQuery_pargs");

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->handler)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->queryId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->request)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("persistent", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->persistent)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryCallback", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += (*(this->queryCallback)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_MessageRouterHandler_onQuery_result::~ClientHandlers_MessageRouterHandler_onQuery_result() noexcept {
}


uint32_t ClientHandlers_MessageRouterHandler_onQuery_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_MessageRouterHandler_onQuery_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("ClientHandlers_MessageRouterHandler_onQuery_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_MessageRouterHandler_onQuery_presult::~ClientHandlers_MessageRouterHandler_onQuery_presult() noexcept {
}


uint32_t ClientHandlers_MessageRouterHandler_onQuery_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


ClientHandlers_MessageRouterHandler_onQueryCanceled_args::~ClientHandlers_MessageRouterHandler_onQueryCanceled_args() noexcept {
}


uint32_t ClientHandlers_MessageRouterHandler_onQueryCanceled_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->handler.read(iprot);
          this->__isset.handler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bid);
          this->__isset.bid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          this->__isset.queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientHandlers_MessageRouterHandler_onQueryCanceled_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_MessageRouterHandler_onQueryCanceled_args");

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->handler.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


ClientHandlers_MessageRouterHandler_onQueryCanceled_pargs::~ClientHandlers_MessageRouterHandler_onQueryCanceled_pargs() noexcept {
}


uint32_t ClientHandlers_MessageRouterHandler_onQueryCanceled_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClientHandlers_MessageRouterHandler_onQueryCanceled_pargs");

  xfer += oprot->writeFieldBegin("handler", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->handler)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->bid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->queryId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

int32_t ClientHandlersClient::connect()
{
  send_connect();
  return recv_connect();
}

void ClientHandlersClient::send_connect()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("connect", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_connect_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t ClientHandlersClient::recv_connect()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("connect") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  ClientHandlers_connect_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connect failed: unknown result");
}

void ClientHandlersClient::log(const std::string& msg)
{
  send_log(msg);
}

void ClientHandlersClient::send_log(const std::string& msg)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("log", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_log_pargs args;
  args.msg = &msg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::AppHandler_GetRegisteredCustomSchemes(std::vector<CustomScheme> & _return)
{
  send_AppHandler_GetRegisteredCustomSchemes();
  recv_AppHandler_GetRegisteredCustomSchemes(_return);
}

void ClientHandlersClient::send_AppHandler_GetRegisteredCustomSchemes()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("AppHandler_GetRegisteredCustomSchemes", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_AppHandler_GetRegisteredCustomSchemes_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::recv_AppHandler_GetRegisteredCustomSchemes(std::vector<CustomScheme> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("AppHandler_GetRegisteredCustomSchemes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientHandlers_AppHandler_GetRegisteredCustomSchemes_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "AppHandler_GetRegisteredCustomSchemes failed: unknown result");
}

void ClientHandlersClient::AppHandler_OnContextInitialized()
{
  send_AppHandler_OnContextInitialized();
  recv_AppHandler_OnContextInitialized();
}

void ClientHandlersClient::send_AppHandler_OnContextInitialized()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("AppHandler_OnContextInitialized", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_AppHandler_OnContextInitialized_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::recv_AppHandler_OnContextInitialized()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("AppHandler_OnContextInitialized") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientHandlers_AppHandler_OnContextInitialized_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void ClientHandlersClient::RenderHandler_GetViewRect(Rect& _return, const int32_t bid)
{
  send_RenderHandler_GetViewRect(bid);
  recv_RenderHandler_GetViewRect(_return);
}

void ClientHandlersClient::send_RenderHandler_GetViewRect(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RenderHandler_GetViewRect", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RenderHandler_GetViewRect_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::recv_RenderHandler_GetViewRect(Rect& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("RenderHandler_GetViewRect") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientHandlers_RenderHandler_GetViewRect_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RenderHandler_GetViewRect failed: unknown result");
}

void ClientHandlersClient::RenderHandler_GetScreenInfo(ScreenInfo& _return, const int32_t bid)
{
  send_RenderHandler_GetScreenInfo(bid);
  recv_RenderHandler_GetScreenInfo(_return);
}

void ClientHandlersClient::send_RenderHandler_GetScreenInfo(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RenderHandler_GetScreenInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RenderHandler_GetScreenInfo_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::recv_RenderHandler_GetScreenInfo(ScreenInfo& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("RenderHandler_GetScreenInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientHandlers_RenderHandler_GetScreenInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RenderHandler_GetScreenInfo failed: unknown result");
}

void ClientHandlersClient::RenderHandler_GetScreenPoint(Point& _return, const int32_t bid, const int32_t viewX, const int32_t viewY)
{
  send_RenderHandler_GetScreenPoint(bid, viewX, viewY);
  recv_RenderHandler_GetScreenPoint(_return);
}

void ClientHandlersClient::send_RenderHandler_GetScreenPoint(const int32_t bid, const int32_t viewX, const int32_t viewY)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RenderHandler_GetScreenPoint", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RenderHandler_GetScreenPoint_pargs args;
  args.bid = &bid;
  args.viewX = &viewX;
  args.viewY = &viewY;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::recv_RenderHandler_GetScreenPoint(Point& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("RenderHandler_GetScreenPoint") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientHandlers_RenderHandler_GetScreenPoint_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RenderHandler_GetScreenPoint failed: unknown result");
}

void ClientHandlersClient::RenderHandler_OnPaint(const int32_t bid, const bool popup, const int32_t dirtyRectsCount, const std::string& sharedMemName, const int64_t sharedMemHandle, const int32_t width, const int32_t height)
{
  send_RenderHandler_OnPaint(bid, popup, dirtyRectsCount, sharedMemName, sharedMemHandle, width, height);
  recv_RenderHandler_OnPaint();
}

void ClientHandlersClient::send_RenderHandler_OnPaint(const int32_t bid, const bool popup, const int32_t dirtyRectsCount, const std::string& sharedMemName, const int64_t sharedMemHandle, const int32_t width, const int32_t height)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RenderHandler_OnPaint", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RenderHandler_OnPaint_pargs args;
  args.bid = &bid;
  args.popup = &popup;
  args.dirtyRectsCount = &dirtyRectsCount;
  args.sharedMemName = &sharedMemName;
  args.sharedMemHandle = &sharedMemHandle;
  args.width = &width;
  args.height = &height;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::recv_RenderHandler_OnPaint()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("RenderHandler_OnPaint") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientHandlers_RenderHandler_OnPaint_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

bool ClientHandlersClient::LifeSpanHandler_OnBeforePopup(const int32_t bid, const std::string& url, const std::string& frameName, const bool gesture)
{
  send_LifeSpanHandler_OnBeforePopup(bid, url, frameName, gesture);
  return recv_LifeSpanHandler_OnBeforePopup();
}

void ClientHandlersClient::send_LifeSpanHandler_OnBeforePopup(const int32_t bid, const std::string& url, const std::string& frameName, const bool gesture)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("LifeSpanHandler_OnBeforePopup", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_LifeSpanHandler_OnBeforePopup_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.frameName = &frameName;
  args.gesture = &gesture;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_LifeSpanHandler_OnBeforePopup()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("LifeSpanHandler_OnBeforePopup") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_LifeSpanHandler_OnBeforePopup_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "LifeSpanHandler_OnBeforePopup failed: unknown result");
}

void ClientHandlersClient::LifeSpanHandler_OnAfterCreated(const int32_t bid)
{
  send_LifeSpanHandler_OnAfterCreated(bid);
}

void ClientHandlersClient::send_LifeSpanHandler_OnAfterCreated(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("LifeSpanHandler_OnAfterCreated", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LifeSpanHandler_OnAfterCreated_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::LifeSpanHandler_DoClose(const int32_t bid)
{
  send_LifeSpanHandler_DoClose(bid);
  return recv_LifeSpanHandler_DoClose();
}

void ClientHandlersClient::send_LifeSpanHandler_DoClose(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("LifeSpanHandler_DoClose", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_LifeSpanHandler_DoClose_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_LifeSpanHandler_DoClose()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("LifeSpanHandler_DoClose") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_LifeSpanHandler_DoClose_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "LifeSpanHandler_DoClose failed: unknown result");
}

void ClientHandlersClient::LifeSpanHandler_OnBeforeClose(const int32_t bid)
{
  send_LifeSpanHandler_OnBeforeClose(bid);
}

void ClientHandlersClient::send_LifeSpanHandler_OnBeforeClose(const int32_t bid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("LifeSpanHandler_OnBeforeClose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LifeSpanHandler_OnBeforeClose_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::LoadHandler_OnLoadingStateChange(const int32_t bid, const bool isLoading, const bool canGoBack, const bool canGoForward)
{
  send_LoadHandler_OnLoadingStateChange(bid, isLoading, canGoBack, canGoForward);
}

void ClientHandlersClient::send_LoadHandler_OnLoadingStateChange(const int32_t bid, const bool isLoading, const bool canGoBack, const bool canGoForward)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("LoadHandler_OnLoadingStateChange", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LoadHandler_OnLoadingStateChange_pargs args;
  args.bid = &bid;
  args.isLoading = &isLoading;
  args.canGoBack = &canGoBack;
  args.canGoForward = &canGoForward;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::LoadHandler_OnLoadStart(const int32_t bid, const int32_t transition_type)
{
  send_LoadHandler_OnLoadStart(bid, transition_type);
}

void ClientHandlersClient::send_LoadHandler_OnLoadStart(const int32_t bid, const int32_t transition_type)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("LoadHandler_OnLoadStart", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LoadHandler_OnLoadStart_pargs args;
  args.bid = &bid;
  args.transition_type = &transition_type;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::LoadHandler_OnLoadEnd(const int32_t bid, const int32_t httpStatusCode)
{
  send_LoadHandler_OnLoadEnd(bid, httpStatusCode);
}

void ClientHandlersClient::send_LoadHandler_OnLoadEnd(const int32_t bid, const int32_t httpStatusCode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("LoadHandler_OnLoadEnd", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LoadHandler_OnLoadEnd_pargs args;
  args.bid = &bid;
  args.httpStatusCode = &httpStatusCode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::LoadHandler_OnLoadError(const int32_t bid, const int32_t errorCode, const std::string& errorText, const std::string& failedUrl)
{
  send_LoadHandler_OnLoadError(bid, errorCode, errorText, failedUrl);
}

void ClientHandlersClient::send_LoadHandler_OnLoadError(const int32_t bid, const int32_t errorCode, const std::string& errorText, const std::string& failedUrl)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("LoadHandler_OnLoadError", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LoadHandler_OnLoadError_pargs args;
  args.bid = &bid;
  args.errorCode = &errorCode;
  args.errorText = &errorText;
  args.failedUrl = &failedUrl;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::DisplayHandler_OnAddressChange(const int32_t bid, const std::string& url)
{
  send_DisplayHandler_OnAddressChange(bid, url);
}

void ClientHandlersClient::send_DisplayHandler_OnAddressChange(const int32_t bid, const std::string& url)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DisplayHandler_OnAddressChange", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_DisplayHandler_OnAddressChange_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::DisplayHandler_OnTitleChange(const int32_t bid, const std::string& title)
{
  send_DisplayHandler_OnTitleChange(bid, title);
}

void ClientHandlersClient::send_DisplayHandler_OnTitleChange(const int32_t bid, const std::string& title)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DisplayHandler_OnTitleChange", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_DisplayHandler_OnTitleChange_pargs args;
  args.bid = &bid;
  args.title = &title;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::DisplayHandler_OnTooltip(const int32_t bid, const std::string& text)
{
  send_DisplayHandler_OnTooltip(bid, text);
  return recv_DisplayHandler_OnTooltip();
}

void ClientHandlersClient::send_DisplayHandler_OnTooltip(const int32_t bid, const std::string& text)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DisplayHandler_OnTooltip", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_DisplayHandler_OnTooltip_pargs args;
  args.bid = &bid;
  args.text = &text;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_DisplayHandler_OnTooltip()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DisplayHandler_OnTooltip") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_DisplayHandler_OnTooltip_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DisplayHandler_OnTooltip failed: unknown result");
}

void ClientHandlersClient::DisplayHandler_OnStatusMessage(const int32_t bid, const std::string& value)
{
  send_DisplayHandler_OnStatusMessage(bid, value);
}

void ClientHandlersClient::send_DisplayHandler_OnStatusMessage(const int32_t bid, const std::string& value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DisplayHandler_OnStatusMessage", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_DisplayHandler_OnStatusMessage_pargs args;
  args.bid = &bid;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::DisplayHandler_OnConsoleMessage(const int32_t bid, const int32_t level, const std::string& message, const std::string& source, const int32_t line)
{
  send_DisplayHandler_OnConsoleMessage(bid, level, message, source, line);
  return recv_DisplayHandler_OnConsoleMessage();
}

void ClientHandlersClient::send_DisplayHandler_OnConsoleMessage(const int32_t bid, const int32_t level, const std::string& message, const std::string& source, const int32_t line)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DisplayHandler_OnConsoleMessage", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_DisplayHandler_OnConsoleMessage_pargs args;
  args.bid = &bid;
  args.level = &level;
  args.message = &message;
  args.source = &source;
  args.line = &line;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_DisplayHandler_OnConsoleMessage()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DisplayHandler_OnConsoleMessage") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_DisplayHandler_OnConsoleMessage_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DisplayHandler_OnConsoleMessage failed: unknown result");
}

bool ClientHandlersClient::RequestHandler_OnBeforeBrowse(const int32_t bid, const  ::thrift_codegen::RObject& request, const bool user_gesture, const bool is_redirect)
{
  send_RequestHandler_OnBeforeBrowse(bid, request, user_gesture, is_redirect);
  return recv_RequestHandler_OnBeforeBrowse();
}

void ClientHandlersClient::send_RequestHandler_OnBeforeBrowse(const int32_t bid, const  ::thrift_codegen::RObject& request, const bool user_gesture, const bool is_redirect)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RequestHandler_OnBeforeBrowse", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RequestHandler_OnBeforeBrowse_pargs args;
  args.bid = &bid;
  args.request = &request;
  args.user_gesture = &user_gesture;
  args.is_redirect = &is_redirect;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_RequestHandler_OnBeforeBrowse()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("RequestHandler_OnBeforeBrowse") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_RequestHandler_OnBeforeBrowse_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RequestHandler_OnBeforeBrowse failed: unknown result");
}

bool ClientHandlersClient::RequestHandler_OnOpenURLFromTab(const int32_t bid, const std::string& target_url, const bool user_gesture)
{
  send_RequestHandler_OnOpenURLFromTab(bid, target_url, user_gesture);
  return recv_RequestHandler_OnOpenURLFromTab();
}

void ClientHandlersClient::send_RequestHandler_OnOpenURLFromTab(const int32_t bid, const std::string& target_url, const bool user_gesture)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RequestHandler_OnOpenURLFromTab", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RequestHandler_OnOpenURLFromTab_pargs args;
  args.bid = &bid;
  args.target_url = &target_url;
  args.user_gesture = &user_gesture;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_RequestHandler_OnOpenURLFromTab()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("RequestHandler_OnOpenURLFromTab") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_RequestHandler_OnOpenURLFromTab_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RequestHandler_OnOpenURLFromTab failed: unknown result");
}

bool ClientHandlersClient::RequestHandler_GetAuthCredentials(const int32_t bid, const std::string& origin_url, const bool isProxy, const std::string& host, const int32_t port, const std::string& realm, const std::string& scheme, const  ::thrift_codegen::RObject& authCallback)
{
  send_RequestHandler_GetAuthCredentials(bid, origin_url, isProxy, host, port, realm, scheme, authCallback);
  return recv_RequestHandler_GetAuthCredentials();
}

void ClientHandlersClient::send_RequestHandler_GetAuthCredentials(const int32_t bid, const std::string& origin_url, const bool isProxy, const std::string& host, const int32_t port, const std::string& realm, const std::string& scheme, const  ::thrift_codegen::RObject& authCallback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RequestHandler_GetAuthCredentials", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RequestHandler_GetAuthCredentials_pargs args;
  args.bid = &bid;
  args.origin_url = &origin_url;
  args.isProxy = &isProxy;
  args.host = &host;
  args.port = &port;
  args.realm = &realm;
  args.scheme = &scheme;
  args.authCallback = &authCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_RequestHandler_GetAuthCredentials()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("RequestHandler_GetAuthCredentials") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_RequestHandler_GetAuthCredentials_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RequestHandler_GetAuthCredentials failed: unknown result");
}

bool ClientHandlersClient::RequestHandler_OnCertificateError(const int32_t bid, const std::string& cert_error, const std::string& request_url, const  ::thrift_codegen::RObject& sslInfo, const  ::thrift_codegen::RObject& callback)
{
  send_RequestHandler_OnCertificateError(bid, cert_error, request_url, sslInfo, callback);
  return recv_RequestHandler_OnCertificateError();
}

void ClientHandlersClient::send_RequestHandler_OnCertificateError(const int32_t bid, const std::string& cert_error, const std::string& request_url, const  ::thrift_codegen::RObject& sslInfo, const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RequestHandler_OnCertificateError", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RequestHandler_OnCertificateError_pargs args;
  args.bid = &bid;
  args.cert_error = &cert_error;
  args.request_url = &request_url;
  args.sslInfo = &sslInfo;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_RequestHandler_OnCertificateError()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("RequestHandler_OnCertificateError") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_RequestHandler_OnCertificateError_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RequestHandler_OnCertificateError failed: unknown result");
}

void ClientHandlersClient::RequestHandler_OnRenderProcessTerminated(const int32_t bid, const std::string& status)
{
  send_RequestHandler_OnRenderProcessTerminated(bid, status);
}

void ClientHandlersClient::send_RequestHandler_OnRenderProcessTerminated(const int32_t bid, const std::string& status)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RequestHandler_OnRenderProcessTerminated", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_RequestHandler_OnRenderProcessTerminated_pargs args;
  args.bid = &bid;
  args.status = &status;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::RequestHandler_GetResourceRequestHandler( ::thrift_codegen::RObject& _return, const int32_t bid, const  ::thrift_codegen::RObject& request, const bool isNavigation, const bool isDownload, const std::string& requestInitiator)
{
  send_RequestHandler_GetResourceRequestHandler(bid, request, isNavigation, isDownload, requestInitiator);
  recv_RequestHandler_GetResourceRequestHandler(_return);
}

void ClientHandlersClient::send_RequestHandler_GetResourceRequestHandler(const int32_t bid, const  ::thrift_codegen::RObject& request, const bool isNavigation, const bool isDownload, const std::string& requestInitiator)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RequestHandler_GetResourceRequestHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RequestHandler_GetResourceRequestHandler_pargs args;
  args.bid = &bid;
  args.request = &request;
  args.isNavigation = &isNavigation;
  args.isDownload = &isDownload;
  args.requestInitiator = &requestInitiator;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::recv_RequestHandler_GetResourceRequestHandler( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("RequestHandler_GetResourceRequestHandler") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientHandlers_RequestHandler_GetResourceRequestHandler_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RequestHandler_GetResourceRequestHandler failed: unknown result");
}

void ClientHandlersClient::ResourceRequestHandler_Dispose(const int32_t rrHandler)
{
  send_ResourceRequestHandler_Dispose(rrHandler);
}

void ClientHandlersClient::send_ResourceRequestHandler_Dispose(const int32_t rrHandler)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ResourceRequestHandler_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_ResourceRequestHandler_Dispose_pargs args;
  args.rrHandler = &rrHandler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::ResourceRequestHandler_GetCookieAccessFilter( ::thrift_codegen::RObject& _return, const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  send_ResourceRequestHandler_GetCookieAccessFilter(rrHandler, bid, request);
  recv_ResourceRequestHandler_GetCookieAccessFilter(_return);
}

void ClientHandlersClient::send_ResourceRequestHandler_GetCookieAccessFilter(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ResourceRequestHandler_GetCookieAccessFilter", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::recv_ResourceRequestHandler_GetCookieAccessFilter( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("ResourceRequestHandler_GetCookieAccessFilter") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_GetCookieAccessFilter failed: unknown result");
}

void ClientHandlersClient::CookieAccessFilter_Dispose(const int32_t filter)
{
  send_CookieAccessFilter_Dispose(filter);
}

void ClientHandlersClient::send_CookieAccessFilter_Dispose(const int32_t filter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CookieAccessFilter_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_CookieAccessFilter_Dispose_pargs args;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::CookieAccessFilter_CanSendCookie(const int32_t filter, const int32_t bid, const  ::thrift_codegen::RObject& request, const std::vector<std::string> & cookie)
{
  send_CookieAccessFilter_CanSendCookie(filter, bid, request, cookie);
  return recv_CookieAccessFilter_CanSendCookie();
}

void ClientHandlersClient::send_CookieAccessFilter_CanSendCookie(const int32_t filter, const int32_t bid, const  ::thrift_codegen::RObject& request, const std::vector<std::string> & cookie)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CookieAccessFilter_CanSendCookie", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_CookieAccessFilter_CanSendCookie_pargs args;
  args.filter = &filter;
  args.bid = &bid;
  args.request = &request;
  args.cookie = &cookie;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_CookieAccessFilter_CanSendCookie()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("CookieAccessFilter_CanSendCookie") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_CookieAccessFilter_CanSendCookie_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieAccessFilter_CanSendCookie failed: unknown result");
}

bool ClientHandlersClient::CookieAccessFilter_CanSaveCookie(const int32_t filter, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::vector<std::string> & cookie)
{
  send_CookieAccessFilter_CanSaveCookie(filter, bid, request, response, cookie);
  return recv_CookieAccessFilter_CanSaveCookie();
}

void ClientHandlersClient::send_CookieAccessFilter_CanSaveCookie(const int32_t filter, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::vector<std::string> & cookie)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CookieAccessFilter_CanSaveCookie", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_CookieAccessFilter_CanSaveCookie_pargs args;
  args.filter = &filter;
  args.bid = &bid;
  args.request = &request;
  args.response = &response;
  args.cookie = &cookie;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_CookieAccessFilter_CanSaveCookie()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("CookieAccessFilter_CanSaveCookie") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_CookieAccessFilter_CanSaveCookie_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieAccessFilter_CanSaveCookie failed: unknown result");
}

bool ClientHandlersClient::ResourceRequestHandler_OnBeforeResourceLoad(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  send_ResourceRequestHandler_OnBeforeResourceLoad(rrHandler, bid, request);
  return recv_ResourceRequestHandler_OnBeforeResourceLoad();
}

void ClientHandlersClient::send_ResourceRequestHandler_OnBeforeResourceLoad(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ResourceRequestHandler_OnBeforeResourceLoad", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_ResourceRequestHandler_OnBeforeResourceLoad()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("ResourceRequestHandler_OnBeforeResourceLoad") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_OnBeforeResourceLoad failed: unknown result");
}

void ClientHandlersClient::ResourceRequestHandler_GetResourceHandler( ::thrift_codegen::RObject& _return, const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  send_ResourceRequestHandler_GetResourceHandler(rrHandler, bid, request);
  recv_ResourceRequestHandler_GetResourceHandler(_return);
}

void ClientHandlersClient::send_ResourceRequestHandler_GetResourceHandler(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ResourceRequestHandler_GetResourceHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_GetResourceHandler_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::recv_ResourceRequestHandler_GetResourceHandler( ::thrift_codegen::RObject& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("ResourceRequestHandler_GetResourceHandler") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientHandlers_ResourceRequestHandler_GetResourceHandler_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_GetResourceHandler failed: unknown result");
}

void ClientHandlersClient::ResourceHandler_Dispose(const int32_t resourceHandler)
{
  send_ResourceHandler_Dispose(resourceHandler);
}

void ClientHandlersClient::send_ResourceHandler_Dispose(const int32_t resourceHandler)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ResourceHandler_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_ResourceHandler_Dispose_pargs args;
  args.resourceHandler = &resourceHandler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::ResourceRequestHandler_OnResourceRedirect(std::string& _return, const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::string& new_url)
{
  send_ResourceRequestHandler_OnResourceRedirect(rrHandler, bid, request, response, new_url);
  recv_ResourceRequestHandler_OnResourceRedirect(_return);
}

void ClientHandlersClient::send_ResourceRequestHandler_OnResourceRedirect(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::string& new_url)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ResourceRequestHandler_OnResourceRedirect", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_OnResourceRedirect_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.response = &response;
  args.new_url = &new_url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void ClientHandlersClient::recv_ResourceRequestHandler_OnResourceRedirect(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("ResourceRequestHandler_OnResourceRedirect") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  ClientHandlers_ResourceRequestHandler_OnResourceRedirect_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_OnResourceRedirect failed: unknown result");
}

bool ClientHandlersClient::ResourceRequestHandler_OnResourceResponse(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response)
{
  send_ResourceRequestHandler_OnResourceResponse(rrHandler, bid, request, response);
  return recv_ResourceRequestHandler_OnResourceResponse();
}

void ClientHandlersClient::send_ResourceRequestHandler_OnResourceResponse(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ResourceRequestHandler_OnResourceResponse", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_OnResourceResponse_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_ResourceRequestHandler_OnResourceResponse()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("ResourceRequestHandler_OnResourceResponse") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_ResourceRequestHandler_OnResourceResponse_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_OnResourceResponse failed: unknown result");
}

void ClientHandlersClient::ResourceRequestHandler_OnResourceLoadComplete(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::string& status, const int64_t receivedContentLength)
{
  send_ResourceRequestHandler_OnResourceLoadComplete(rrHandler, bid, request, response, status, receivedContentLength);
}

void ClientHandlersClient::send_ResourceRequestHandler_OnResourceLoadComplete(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::string& status, const int64_t receivedContentLength)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ResourceRequestHandler_OnResourceLoadComplete", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.response = &response;
  args.status = &status;
  args.receivedContentLength = &receivedContentLength;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::ResourceRequestHandler_OnProtocolExecution(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const bool allowOsExecution)
{
  send_ResourceRequestHandler_OnProtocolExecution(rrHandler, bid, request, allowOsExecution);
  return recv_ResourceRequestHandler_OnProtocolExecution();
}

void ClientHandlersClient::send_ResourceRequestHandler_OnProtocolExecution(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const bool allowOsExecution)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ResourceRequestHandler_OnProtocolExecution", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_OnProtocolExecution_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.allowOsExecution = &allowOsExecution;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_ResourceRequestHandler_OnProtocolExecution()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("ResourceRequestHandler_OnProtocolExecution") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_ResourceRequestHandler_OnProtocolExecution_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_OnProtocolExecution failed: unknown result");
}

bool ClientHandlersClient::MessageRouterHandler_onQuery(const  ::thrift_codegen::RObject& handler, const int32_t bid, const int64_t queryId, const std::string& request, const bool persistent, const  ::thrift_codegen::RObject& queryCallback)
{
  send_MessageRouterHandler_onQuery(handler, bid, queryId, request, persistent, queryCallback);
  return recv_MessageRouterHandler_onQuery();
}

void ClientHandlersClient::send_MessageRouterHandler_onQuery(const  ::thrift_codegen::RObject& handler, const int32_t bid, const int64_t queryId, const std::string& request, const bool persistent, const  ::thrift_codegen::RObject& queryCallback)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouterHandler_onQuery", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_MessageRouterHandler_onQuery_pargs args;
  args.handler = &handler;
  args.bid = &bid;
  args.queryId = &queryId;
  args.request = &request;
  args.persistent = &persistent;
  args.queryCallback = &queryCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersClient::recv_MessageRouterHandler_onQuery()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MessageRouterHandler_onQuery") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  ClientHandlers_MessageRouterHandler_onQuery_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MessageRouterHandler_onQuery failed: unknown result");
}

void ClientHandlersClient::MessageRouterHandler_onQueryCanceled(const  ::thrift_codegen::RObject& handler, const int32_t bid, const int64_t queryId)
{
  send_MessageRouterHandler_onQueryCanceled(handler, bid, queryId);
}

void ClientHandlersClient::send_MessageRouterHandler_onQueryCanceled(const  ::thrift_codegen::RObject& handler, const int32_t bid, const int64_t queryId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MessageRouterHandler_onQueryCanceled", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_MessageRouterHandler_onQueryCanceled_pargs args;
  args.handler = &handler;
  args.bid = &bid;
  args.queryId = &queryId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool ClientHandlersProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void ClientHandlersProcessor::process_connect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.connect", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.connect");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.connect");
  }

  ClientHandlers_connect_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.connect", bytes);
  }

  ClientHandlers_connect_result result;
  try {
    result.success = iface_->connect();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.connect");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("connect", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.connect");
  }

  oprot->writeMessageBegin("connect", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.connect", bytes);
  }
}

void ClientHandlersProcessor::process_log(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.log", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.log");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.log");
  }

  ClientHandlers_log_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.log", bytes);
  }

  try {
    iface_->log(args.msg);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.log");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.log");
  }

  return;
}

void ClientHandlersProcessor::process_AppHandler_GetRegisteredCustomSchemes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.AppHandler_GetRegisteredCustomSchemes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.AppHandler_GetRegisteredCustomSchemes");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.AppHandler_GetRegisteredCustomSchemes");
  }

  ClientHandlers_AppHandler_GetRegisteredCustomSchemes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.AppHandler_GetRegisteredCustomSchemes", bytes);
  }

  ClientHandlers_AppHandler_GetRegisteredCustomSchemes_result result;
  try {
    iface_->AppHandler_GetRegisteredCustomSchemes(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.AppHandler_GetRegisteredCustomSchemes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("AppHandler_GetRegisteredCustomSchemes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.AppHandler_GetRegisteredCustomSchemes");
  }

  oprot->writeMessageBegin("AppHandler_GetRegisteredCustomSchemes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.AppHandler_GetRegisteredCustomSchemes", bytes);
  }
}

void ClientHandlersProcessor::process_AppHandler_OnContextInitialized(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.AppHandler_OnContextInitialized", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.AppHandler_OnContextInitialized");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.AppHandler_OnContextInitialized");
  }

  ClientHandlers_AppHandler_OnContextInitialized_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.AppHandler_OnContextInitialized", bytes);
  }

  ClientHandlers_AppHandler_OnContextInitialized_result result;
  try {
    iface_->AppHandler_OnContextInitialized();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.AppHandler_OnContextInitialized");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("AppHandler_OnContextInitialized", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.AppHandler_OnContextInitialized");
  }

  oprot->writeMessageBegin("AppHandler_OnContextInitialized", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.AppHandler_OnContextInitialized", bytes);
  }
}

void ClientHandlersProcessor::process_RenderHandler_GetViewRect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.RenderHandler_GetViewRect", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.RenderHandler_GetViewRect");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.RenderHandler_GetViewRect");
  }

  ClientHandlers_RenderHandler_GetViewRect_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.RenderHandler_GetViewRect", bytes);
  }

  ClientHandlers_RenderHandler_GetViewRect_result result;
  try {
    iface_->RenderHandler_GetViewRect(result.success, args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.RenderHandler_GetViewRect");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("RenderHandler_GetViewRect", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.RenderHandler_GetViewRect");
  }

  oprot->writeMessageBegin("RenderHandler_GetViewRect", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.RenderHandler_GetViewRect", bytes);
  }
}

void ClientHandlersProcessor::process_RenderHandler_GetScreenInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.RenderHandler_GetScreenInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.RenderHandler_GetScreenInfo");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.RenderHandler_GetScreenInfo");
  }

  ClientHandlers_RenderHandler_GetScreenInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.RenderHandler_GetScreenInfo", bytes);
  }

  ClientHandlers_RenderHandler_GetScreenInfo_result result;
  try {
    iface_->RenderHandler_GetScreenInfo(result.success, args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.RenderHandler_GetScreenInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("RenderHandler_GetScreenInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.RenderHandler_GetScreenInfo");
  }

  oprot->writeMessageBegin("RenderHandler_GetScreenInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.RenderHandler_GetScreenInfo", bytes);
  }
}

void ClientHandlersProcessor::process_RenderHandler_GetScreenPoint(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.RenderHandler_GetScreenPoint", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.RenderHandler_GetScreenPoint");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.RenderHandler_GetScreenPoint");
  }

  ClientHandlers_RenderHandler_GetScreenPoint_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.RenderHandler_GetScreenPoint", bytes);
  }

  ClientHandlers_RenderHandler_GetScreenPoint_result result;
  try {
    iface_->RenderHandler_GetScreenPoint(result.success, args.bid, args.viewX, args.viewY);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.RenderHandler_GetScreenPoint");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("RenderHandler_GetScreenPoint", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.RenderHandler_GetScreenPoint");
  }

  oprot->writeMessageBegin("RenderHandler_GetScreenPoint", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.RenderHandler_GetScreenPoint", bytes);
  }
}

void ClientHandlersProcessor::process_RenderHandler_OnPaint(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.RenderHandler_OnPaint", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.RenderHandler_OnPaint");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.RenderHandler_OnPaint");
  }

  ClientHandlers_RenderHandler_OnPaint_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.RenderHandler_OnPaint", bytes);
  }

  ClientHandlers_RenderHandler_OnPaint_result result;
  try {
    iface_->RenderHandler_OnPaint(args.bid, args.popup, args.dirtyRectsCount, args.sharedMemName, args.sharedMemHandle, args.width, args.height);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.RenderHandler_OnPaint");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("RenderHandler_OnPaint", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.RenderHandler_OnPaint");
  }

  oprot->writeMessageBegin("RenderHandler_OnPaint", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.RenderHandler_OnPaint", bytes);
  }
}

void ClientHandlersProcessor::process_LifeSpanHandler_OnBeforePopup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.LifeSpanHandler_OnBeforePopup", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.LifeSpanHandler_OnBeforePopup");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.LifeSpanHandler_OnBeforePopup");
  }

  ClientHandlers_LifeSpanHandler_OnBeforePopup_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.LifeSpanHandler_OnBeforePopup", bytes);
  }

  ClientHandlers_LifeSpanHandler_OnBeforePopup_result result;
  try {
    result.success = iface_->LifeSpanHandler_OnBeforePopup(args.bid, args.url, args.frameName, args.gesture);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.LifeSpanHandler_OnBeforePopup");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("LifeSpanHandler_OnBeforePopup", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.LifeSpanHandler_OnBeforePopup");
  }

  oprot->writeMessageBegin("LifeSpanHandler_OnBeforePopup", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.LifeSpanHandler_OnBeforePopup", bytes);
  }
}

void ClientHandlersProcessor::process_LifeSpanHandler_OnAfterCreated(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.LifeSpanHandler_OnAfterCreated", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.LifeSpanHandler_OnAfterCreated");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.LifeSpanHandler_OnAfterCreated");
  }

  ClientHandlers_LifeSpanHandler_OnAfterCreated_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.LifeSpanHandler_OnAfterCreated", bytes);
  }

  try {
    iface_->LifeSpanHandler_OnAfterCreated(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.LifeSpanHandler_OnAfterCreated");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.LifeSpanHandler_OnAfterCreated");
  }

  return;
}

void ClientHandlersProcessor::process_LifeSpanHandler_DoClose(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.LifeSpanHandler_DoClose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.LifeSpanHandler_DoClose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.LifeSpanHandler_DoClose");
  }

  ClientHandlers_LifeSpanHandler_DoClose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.LifeSpanHandler_DoClose", bytes);
  }

  ClientHandlers_LifeSpanHandler_DoClose_result result;
  try {
    result.success = iface_->LifeSpanHandler_DoClose(args.bid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.LifeSpanHandler_DoClose");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("LifeSpanHandler_DoClose", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.LifeSpanHandler_DoClose");
  }

  oprot->writeMessageBegin("LifeSpanHandler_DoClose", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.LifeSpanHandler_DoClose", bytes);
  }
}

void ClientHandlersProcessor::process_LifeSpanHandler_OnBeforeClose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.LifeSpanHandler_OnBeforeClose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.LifeSpanHandler_OnBeforeClose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.LifeSpanHandler_OnBeforeClose");
  }

  ClientHandlers_LifeSpanHandler_OnBeforeClose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.LifeSpanHandler_OnBeforeClose", bytes);
  }

  try {
    iface_->LifeSpanHandler_OnBeforeClose(args.bid);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.LifeSpanHandler_OnBeforeClose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.LifeSpanHandler_OnBeforeClose");
  }

  return;
}

void ClientHandlersProcessor::process_LoadHandler_OnLoadingStateChange(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.LoadHandler_OnLoadingStateChange", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.LoadHandler_OnLoadingStateChange");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.LoadHandler_OnLoadingStateChange");
  }

  ClientHandlers_LoadHandler_OnLoadingStateChange_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.LoadHandler_OnLoadingStateChange", bytes);
  }

  try {
    iface_->LoadHandler_OnLoadingStateChange(args.bid, args.isLoading, args.canGoBack, args.canGoForward);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.LoadHandler_OnLoadingStateChange");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.LoadHandler_OnLoadingStateChange");
  }

  return;
}

void ClientHandlersProcessor::process_LoadHandler_OnLoadStart(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.LoadHandler_OnLoadStart", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.LoadHandler_OnLoadStart");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.LoadHandler_OnLoadStart");
  }

  ClientHandlers_LoadHandler_OnLoadStart_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.LoadHandler_OnLoadStart", bytes);
  }

  try {
    iface_->LoadHandler_OnLoadStart(args.bid, args.transition_type);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.LoadHandler_OnLoadStart");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.LoadHandler_OnLoadStart");
  }

  return;
}

void ClientHandlersProcessor::process_LoadHandler_OnLoadEnd(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.LoadHandler_OnLoadEnd", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.LoadHandler_OnLoadEnd");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.LoadHandler_OnLoadEnd");
  }

  ClientHandlers_LoadHandler_OnLoadEnd_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.LoadHandler_OnLoadEnd", bytes);
  }

  try {
    iface_->LoadHandler_OnLoadEnd(args.bid, args.httpStatusCode);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.LoadHandler_OnLoadEnd");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.LoadHandler_OnLoadEnd");
  }

  return;
}

void ClientHandlersProcessor::process_LoadHandler_OnLoadError(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.LoadHandler_OnLoadError", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.LoadHandler_OnLoadError");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.LoadHandler_OnLoadError");
  }

  ClientHandlers_LoadHandler_OnLoadError_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.LoadHandler_OnLoadError", bytes);
  }

  try {
    iface_->LoadHandler_OnLoadError(args.bid, args.errorCode, args.errorText, args.failedUrl);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.LoadHandler_OnLoadError");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.LoadHandler_OnLoadError");
  }

  return;
}

void ClientHandlersProcessor::process_DisplayHandler_OnAddressChange(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.DisplayHandler_OnAddressChange", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.DisplayHandler_OnAddressChange");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.DisplayHandler_OnAddressChange");
  }

  ClientHandlers_DisplayHandler_OnAddressChange_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.DisplayHandler_OnAddressChange", bytes);
  }

  try {
    iface_->DisplayHandler_OnAddressChange(args.bid, args.url);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.DisplayHandler_OnAddressChange");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.DisplayHandler_OnAddressChange");
  }

  return;
}

void ClientHandlersProcessor::process_DisplayHandler_OnTitleChange(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.DisplayHandler_OnTitleChange", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.DisplayHandler_OnTitleChange");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.DisplayHandler_OnTitleChange");
  }

  ClientHandlers_DisplayHandler_OnTitleChange_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.DisplayHandler_OnTitleChange", bytes);
  }

  try {
    iface_->DisplayHandler_OnTitleChange(args.bid, args.title);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.DisplayHandler_OnTitleChange");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.DisplayHandler_OnTitleChange");
  }

  return;
}

void ClientHandlersProcessor::process_DisplayHandler_OnTooltip(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.DisplayHandler_OnTooltip", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.DisplayHandler_OnTooltip");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.DisplayHandler_OnTooltip");
  }

  ClientHandlers_DisplayHandler_OnTooltip_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.DisplayHandler_OnTooltip", bytes);
  }

  ClientHandlers_DisplayHandler_OnTooltip_result result;
  try {
    result.success = iface_->DisplayHandler_OnTooltip(args.bid, args.text);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.DisplayHandler_OnTooltip");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DisplayHandler_OnTooltip", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.DisplayHandler_OnTooltip");
  }

  oprot->writeMessageBegin("DisplayHandler_OnTooltip", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.DisplayHandler_OnTooltip", bytes);
  }
}

void ClientHandlersProcessor::process_DisplayHandler_OnStatusMessage(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.DisplayHandler_OnStatusMessage", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.DisplayHandler_OnStatusMessage");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.DisplayHandler_OnStatusMessage");
  }

  ClientHandlers_DisplayHandler_OnStatusMessage_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.DisplayHandler_OnStatusMessage", bytes);
  }

  try {
    iface_->DisplayHandler_OnStatusMessage(args.bid, args.value);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.DisplayHandler_OnStatusMessage");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.DisplayHandler_OnStatusMessage");
  }

  return;
}

void ClientHandlersProcessor::process_DisplayHandler_OnConsoleMessage(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.DisplayHandler_OnConsoleMessage", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.DisplayHandler_OnConsoleMessage");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.DisplayHandler_OnConsoleMessage");
  }

  ClientHandlers_DisplayHandler_OnConsoleMessage_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.DisplayHandler_OnConsoleMessage", bytes);
  }

  ClientHandlers_DisplayHandler_OnConsoleMessage_result result;
  try {
    result.success = iface_->DisplayHandler_OnConsoleMessage(args.bid, args.level, args.message, args.source, args.line);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.DisplayHandler_OnConsoleMessage");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DisplayHandler_OnConsoleMessage", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.DisplayHandler_OnConsoleMessage");
  }

  oprot->writeMessageBegin("DisplayHandler_OnConsoleMessage", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.DisplayHandler_OnConsoleMessage", bytes);
  }
}

void ClientHandlersProcessor::process_RequestHandler_OnBeforeBrowse(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.RequestHandler_OnBeforeBrowse", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.RequestHandler_OnBeforeBrowse");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.RequestHandler_OnBeforeBrowse");
  }

  ClientHandlers_RequestHandler_OnBeforeBrowse_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.RequestHandler_OnBeforeBrowse", bytes);
  }

  ClientHandlers_RequestHandler_OnBeforeBrowse_result result;
  try {
    result.success = iface_->RequestHandler_OnBeforeBrowse(args.bid, args.request, args.user_gesture, args.is_redirect);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.RequestHandler_OnBeforeBrowse");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("RequestHandler_OnBeforeBrowse", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.RequestHandler_OnBeforeBrowse");
  }

  oprot->writeMessageBegin("RequestHandler_OnBeforeBrowse", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.RequestHandler_OnBeforeBrowse", bytes);
  }
}

void ClientHandlersProcessor::process_RequestHandler_OnOpenURLFromTab(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.RequestHandler_OnOpenURLFromTab", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.RequestHandler_OnOpenURLFromTab");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.RequestHandler_OnOpenURLFromTab");
  }

  ClientHandlers_RequestHandler_OnOpenURLFromTab_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.RequestHandler_OnOpenURLFromTab", bytes);
  }

  ClientHandlers_RequestHandler_OnOpenURLFromTab_result result;
  try {
    result.success = iface_->RequestHandler_OnOpenURLFromTab(args.bid, args.target_url, args.user_gesture);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.RequestHandler_OnOpenURLFromTab");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("RequestHandler_OnOpenURLFromTab", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.RequestHandler_OnOpenURLFromTab");
  }

  oprot->writeMessageBegin("RequestHandler_OnOpenURLFromTab", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.RequestHandler_OnOpenURLFromTab", bytes);
  }
}

void ClientHandlersProcessor::process_RequestHandler_GetAuthCredentials(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.RequestHandler_GetAuthCredentials", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.RequestHandler_GetAuthCredentials");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.RequestHandler_GetAuthCredentials");
  }

  ClientHandlers_RequestHandler_GetAuthCredentials_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.RequestHandler_GetAuthCredentials", bytes);
  }

  ClientHandlers_RequestHandler_GetAuthCredentials_result result;
  try {
    result.success = iface_->RequestHandler_GetAuthCredentials(args.bid, args.origin_url, args.isProxy, args.host, args.port, args.realm, args.scheme, args.authCallback);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.RequestHandler_GetAuthCredentials");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("RequestHandler_GetAuthCredentials", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.RequestHandler_GetAuthCredentials");
  }

  oprot->writeMessageBegin("RequestHandler_GetAuthCredentials", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.RequestHandler_GetAuthCredentials", bytes);
  }
}

void ClientHandlersProcessor::process_RequestHandler_OnCertificateError(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.RequestHandler_OnCertificateError", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.RequestHandler_OnCertificateError");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.RequestHandler_OnCertificateError");
  }

  ClientHandlers_RequestHandler_OnCertificateError_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.RequestHandler_OnCertificateError", bytes);
  }

  ClientHandlers_RequestHandler_OnCertificateError_result result;
  try {
    result.success = iface_->RequestHandler_OnCertificateError(args.bid, args.cert_error, args.request_url, args.sslInfo, args.callback);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.RequestHandler_OnCertificateError");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("RequestHandler_OnCertificateError", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.RequestHandler_OnCertificateError");
  }

  oprot->writeMessageBegin("RequestHandler_OnCertificateError", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.RequestHandler_OnCertificateError", bytes);
  }
}

void ClientHandlersProcessor::process_RequestHandler_OnRenderProcessTerminated(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.RequestHandler_OnRenderProcessTerminated", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.RequestHandler_OnRenderProcessTerminated");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.RequestHandler_OnRenderProcessTerminated");
  }

  ClientHandlers_RequestHandler_OnRenderProcessTerminated_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.RequestHandler_OnRenderProcessTerminated", bytes);
  }

  try {
    iface_->RequestHandler_OnRenderProcessTerminated(args.bid, args.status);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.RequestHandler_OnRenderProcessTerminated");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.RequestHandler_OnRenderProcessTerminated");
  }

  return;
}

void ClientHandlersProcessor::process_RequestHandler_GetResourceRequestHandler(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.RequestHandler_GetResourceRequestHandler", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.RequestHandler_GetResourceRequestHandler");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.RequestHandler_GetResourceRequestHandler");
  }

  ClientHandlers_RequestHandler_GetResourceRequestHandler_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.RequestHandler_GetResourceRequestHandler", bytes);
  }

  ClientHandlers_RequestHandler_GetResourceRequestHandler_result result;
  try {
    iface_->RequestHandler_GetResourceRequestHandler(result.success, args.bid, args.request, args.isNavigation, args.isDownload, args.requestInitiator);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.RequestHandler_GetResourceRequestHandler");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("RequestHandler_GetResourceRequestHandler", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.RequestHandler_GetResourceRequestHandler");
  }

  oprot->writeMessageBegin("RequestHandler_GetResourceRequestHandler", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.RequestHandler_GetResourceRequestHandler", bytes);
  }
}

void ClientHandlersProcessor::process_ResourceRequestHandler_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.ResourceRequestHandler_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.ResourceRequestHandler_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.ResourceRequestHandler_Dispose");
  }

  ClientHandlers_ResourceRequestHandler_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.ResourceRequestHandler_Dispose", bytes);
  }

  try {
    iface_->ResourceRequestHandler_Dispose(args.rrHandler);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.ResourceRequestHandler_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.ResourceRequestHandler_Dispose");
  }

  return;
}

void ClientHandlersProcessor::process_ResourceRequestHandler_GetCookieAccessFilter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.ResourceRequestHandler_GetCookieAccessFilter", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.ResourceRequestHandler_GetCookieAccessFilter");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.ResourceRequestHandler_GetCookieAccessFilter");
  }

  ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.ResourceRequestHandler_GetCookieAccessFilter", bytes);
  }

  ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_result result;
  try {
    iface_->ResourceRequestHandler_GetCookieAccessFilter(result.success, args.rrHandler, args.bid, args.request);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.ResourceRequestHandler_GetCookieAccessFilter");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ResourceRequestHandler_GetCookieAccessFilter", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.ResourceRequestHandler_GetCookieAccessFilter");
  }

  oprot->writeMessageBegin("ResourceRequestHandler_GetCookieAccessFilter", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.ResourceRequestHandler_GetCookieAccessFilter", bytes);
  }
}

void ClientHandlersProcessor::process_CookieAccessFilter_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.CookieAccessFilter_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.CookieAccessFilter_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.CookieAccessFilter_Dispose");
  }

  ClientHandlers_CookieAccessFilter_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.CookieAccessFilter_Dispose", bytes);
  }

  try {
    iface_->CookieAccessFilter_Dispose(args.filter);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.CookieAccessFilter_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.CookieAccessFilter_Dispose");
  }

  return;
}

void ClientHandlersProcessor::process_CookieAccessFilter_CanSendCookie(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.CookieAccessFilter_CanSendCookie", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.CookieAccessFilter_CanSendCookie");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.CookieAccessFilter_CanSendCookie");
  }

  ClientHandlers_CookieAccessFilter_CanSendCookie_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.CookieAccessFilter_CanSendCookie", bytes);
  }

  ClientHandlers_CookieAccessFilter_CanSendCookie_result result;
  try {
    result.success = iface_->CookieAccessFilter_CanSendCookie(args.filter, args.bid, args.request, args.cookie);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.CookieAccessFilter_CanSendCookie");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("CookieAccessFilter_CanSendCookie", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.CookieAccessFilter_CanSendCookie");
  }

  oprot->writeMessageBegin("CookieAccessFilter_CanSendCookie", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.CookieAccessFilter_CanSendCookie", bytes);
  }
}

void ClientHandlersProcessor::process_CookieAccessFilter_CanSaveCookie(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.CookieAccessFilter_CanSaveCookie", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.CookieAccessFilter_CanSaveCookie");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.CookieAccessFilter_CanSaveCookie");
  }

  ClientHandlers_CookieAccessFilter_CanSaveCookie_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.CookieAccessFilter_CanSaveCookie", bytes);
  }

  ClientHandlers_CookieAccessFilter_CanSaveCookie_result result;
  try {
    result.success = iface_->CookieAccessFilter_CanSaveCookie(args.filter, args.bid, args.request, args.response, args.cookie);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.CookieAccessFilter_CanSaveCookie");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("CookieAccessFilter_CanSaveCookie", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.CookieAccessFilter_CanSaveCookie");
  }

  oprot->writeMessageBegin("CookieAccessFilter_CanSaveCookie", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.CookieAccessFilter_CanSaveCookie", bytes);
  }
}

void ClientHandlersProcessor::process_ResourceRequestHandler_OnBeforeResourceLoad(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.ResourceRequestHandler_OnBeforeResourceLoad", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.ResourceRequestHandler_OnBeforeResourceLoad");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.ResourceRequestHandler_OnBeforeResourceLoad");
  }

  ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.ResourceRequestHandler_OnBeforeResourceLoad", bytes);
  }

  ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_result result;
  try {
    result.success = iface_->ResourceRequestHandler_OnBeforeResourceLoad(args.rrHandler, args.bid, args.request);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.ResourceRequestHandler_OnBeforeResourceLoad");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ResourceRequestHandler_OnBeforeResourceLoad", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.ResourceRequestHandler_OnBeforeResourceLoad");
  }

  oprot->writeMessageBegin("ResourceRequestHandler_OnBeforeResourceLoad", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.ResourceRequestHandler_OnBeforeResourceLoad", bytes);
  }
}

void ClientHandlersProcessor::process_ResourceRequestHandler_GetResourceHandler(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.ResourceRequestHandler_GetResourceHandler", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.ResourceRequestHandler_GetResourceHandler");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.ResourceRequestHandler_GetResourceHandler");
  }

  ClientHandlers_ResourceRequestHandler_GetResourceHandler_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.ResourceRequestHandler_GetResourceHandler", bytes);
  }

  ClientHandlers_ResourceRequestHandler_GetResourceHandler_result result;
  try {
    iface_->ResourceRequestHandler_GetResourceHandler(result.success, args.rrHandler, args.bid, args.request);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.ResourceRequestHandler_GetResourceHandler");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ResourceRequestHandler_GetResourceHandler", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.ResourceRequestHandler_GetResourceHandler");
  }

  oprot->writeMessageBegin("ResourceRequestHandler_GetResourceHandler", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.ResourceRequestHandler_GetResourceHandler", bytes);
  }
}

void ClientHandlersProcessor::process_ResourceHandler_Dispose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.ResourceHandler_Dispose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.ResourceHandler_Dispose");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.ResourceHandler_Dispose");
  }

  ClientHandlers_ResourceHandler_Dispose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.ResourceHandler_Dispose", bytes);
  }

  try {
    iface_->ResourceHandler_Dispose(args.resourceHandler);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.ResourceHandler_Dispose");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.ResourceHandler_Dispose");
  }

  return;
}

void ClientHandlersProcessor::process_ResourceRequestHandler_OnResourceRedirect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.ResourceRequestHandler_OnResourceRedirect", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.ResourceRequestHandler_OnResourceRedirect");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceRedirect");
  }

  ClientHandlers_ResourceRequestHandler_OnResourceRedirect_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceRedirect", bytes);
  }

  ClientHandlers_ResourceRequestHandler_OnResourceRedirect_result result;
  try {
    iface_->ResourceRequestHandler_OnResourceRedirect(result.success, args.rrHandler, args.bid, args.request, args.response, args.new_url);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceRedirect");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ResourceRequestHandler_OnResourceRedirect", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceRedirect");
  }

  oprot->writeMessageBegin("ResourceRequestHandler_OnResourceRedirect", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceRedirect", bytes);
  }
}

void ClientHandlersProcessor::process_ResourceRequestHandler_OnResourceResponse(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.ResourceRequestHandler_OnResourceResponse", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.ResourceRequestHandler_OnResourceResponse");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceResponse");
  }

  ClientHandlers_ResourceRequestHandler_OnResourceResponse_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceResponse", bytes);
  }

  ClientHandlers_ResourceRequestHandler_OnResourceResponse_result result;
  try {
    result.success = iface_->ResourceRequestHandler_OnResourceResponse(args.rrHandler, args.bid, args.request, args.response);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceResponse");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ResourceRequestHandler_OnResourceResponse", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceResponse");
  }

  oprot->writeMessageBegin("ResourceRequestHandler_OnResourceResponse", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceResponse", bytes);
  }
}

void ClientHandlersProcessor::process_ResourceRequestHandler_OnResourceLoadComplete(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.ResourceRequestHandler_OnResourceLoadComplete", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.ResourceRequestHandler_OnResourceLoadComplete");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceLoadComplete");
  }

  ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceLoadComplete", bytes);
  }

  try {
    iface_->ResourceRequestHandler_OnResourceLoadComplete(args.rrHandler, args.bid, args.request, args.response, args.status, args.receivedContentLength);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceLoadComplete");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.ResourceRequestHandler_OnResourceLoadComplete");
  }

  return;
}

void ClientHandlersProcessor::process_ResourceRequestHandler_OnProtocolExecution(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.ResourceRequestHandler_OnProtocolExecution", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.ResourceRequestHandler_OnProtocolExecution");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.ResourceRequestHandler_OnProtocolExecution");
  }

  ClientHandlers_ResourceRequestHandler_OnProtocolExecution_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.ResourceRequestHandler_OnProtocolExecution", bytes);
  }

  ClientHandlers_ResourceRequestHandler_OnProtocolExecution_result result;
  try {
    result.success = iface_->ResourceRequestHandler_OnProtocolExecution(args.rrHandler, args.bid, args.request, args.allowOsExecution);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.ResourceRequestHandler_OnProtocolExecution");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ResourceRequestHandler_OnProtocolExecution", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.ResourceRequestHandler_OnProtocolExecution");
  }

  oprot->writeMessageBegin("ResourceRequestHandler_OnProtocolExecution", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.ResourceRequestHandler_OnProtocolExecution", bytes);
  }
}

void ClientHandlersProcessor::process_MessageRouterHandler_onQuery(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.MessageRouterHandler_onQuery", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.MessageRouterHandler_onQuery");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.MessageRouterHandler_onQuery");
  }

  ClientHandlers_MessageRouterHandler_onQuery_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.MessageRouterHandler_onQuery", bytes);
  }

  ClientHandlers_MessageRouterHandler_onQuery_result result;
  try {
    result.success = iface_->MessageRouterHandler_onQuery(args.handler, args.bid, args.queryId, args.request, args.persistent, args.queryCallback);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.MessageRouterHandler_onQuery");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MessageRouterHandler_onQuery", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "ClientHandlers.MessageRouterHandler_onQuery");
  }

  oprot->writeMessageBegin("MessageRouterHandler_onQuery", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "ClientHandlers.MessageRouterHandler_onQuery", bytes);
  }
}

void ClientHandlersProcessor::process_MessageRouterHandler_onQueryCanceled(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("ClientHandlers.MessageRouterHandler_onQueryCanceled", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "ClientHandlers.MessageRouterHandler_onQueryCanceled");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "ClientHandlers.MessageRouterHandler_onQueryCanceled");
  }

  ClientHandlers_MessageRouterHandler_onQueryCanceled_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "ClientHandlers.MessageRouterHandler_onQueryCanceled", bytes);
  }

  try {
    iface_->MessageRouterHandler_onQueryCanceled(args.handler, args.bid, args.queryId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "ClientHandlers.MessageRouterHandler_onQueryCanceled");
    }
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->asyncComplete(ctx, "ClientHandlers.MessageRouterHandler_onQueryCanceled");
  }

  return;
}

::std::shared_ptr< ::apache::thrift::TProcessor > ClientHandlersProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< ClientHandlersIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< ClientHandlersIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new ClientHandlersProcessor(handler));
  return processor;
}

int32_t ClientHandlersConcurrentClient::connect()
{
  int32_t seqid = send_connect();
  return recv_connect(seqid);
}

int32_t ClientHandlersConcurrentClient::send_connect()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("connect", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_connect_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t ClientHandlersConcurrentClient::recv_connect(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("connect") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      ClientHandlers_connect_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "connect failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::log(const std::string& msg)
{
  send_log(msg);
}

void ClientHandlersConcurrentClient::send_log(const std::string& msg)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("log", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_log_pargs args;
  args.msg = &msg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ClientHandlersConcurrentClient::AppHandler_GetRegisteredCustomSchemes(std::vector<CustomScheme> & _return)
{
  int32_t seqid = send_AppHandler_GetRegisteredCustomSchemes();
  recv_AppHandler_GetRegisteredCustomSchemes(_return, seqid);
}

int32_t ClientHandlersConcurrentClient::send_AppHandler_GetRegisteredCustomSchemes()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("AppHandler_GetRegisteredCustomSchemes", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_AppHandler_GetRegisteredCustomSchemes_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ClientHandlersConcurrentClient::recv_AppHandler_GetRegisteredCustomSchemes(std::vector<CustomScheme> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("AppHandler_GetRegisteredCustomSchemes") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ClientHandlers_AppHandler_GetRegisteredCustomSchemes_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "AppHandler_GetRegisteredCustomSchemes failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::AppHandler_OnContextInitialized()
{
  int32_t seqid = send_AppHandler_OnContextInitialized();
  recv_AppHandler_OnContextInitialized(seqid);
}

int32_t ClientHandlersConcurrentClient::send_AppHandler_OnContextInitialized()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("AppHandler_OnContextInitialized", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_AppHandler_OnContextInitialized_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ClientHandlersConcurrentClient::recv_AppHandler_OnContextInitialized(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("AppHandler_OnContextInitialized") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ClientHandlers_AppHandler_OnContextInitialized_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::RenderHandler_GetViewRect(Rect& _return, const int32_t bid)
{
  int32_t seqid = send_RenderHandler_GetViewRect(bid);
  recv_RenderHandler_GetViewRect(_return, seqid);
}

int32_t ClientHandlersConcurrentClient::send_RenderHandler_GetViewRect(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RenderHandler_GetViewRect", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RenderHandler_GetViewRect_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ClientHandlersConcurrentClient::recv_RenderHandler_GetViewRect(Rect& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("RenderHandler_GetViewRect") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ClientHandlers_RenderHandler_GetViewRect_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RenderHandler_GetViewRect failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::RenderHandler_GetScreenInfo(ScreenInfo& _return, const int32_t bid)
{
  int32_t seqid = send_RenderHandler_GetScreenInfo(bid);
  recv_RenderHandler_GetScreenInfo(_return, seqid);
}

int32_t ClientHandlersConcurrentClient::send_RenderHandler_GetScreenInfo(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RenderHandler_GetScreenInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RenderHandler_GetScreenInfo_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ClientHandlersConcurrentClient::recv_RenderHandler_GetScreenInfo(ScreenInfo& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("RenderHandler_GetScreenInfo") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ClientHandlers_RenderHandler_GetScreenInfo_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RenderHandler_GetScreenInfo failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::RenderHandler_GetScreenPoint(Point& _return, const int32_t bid, const int32_t viewX, const int32_t viewY)
{
  int32_t seqid = send_RenderHandler_GetScreenPoint(bid, viewX, viewY);
  recv_RenderHandler_GetScreenPoint(_return, seqid);
}

int32_t ClientHandlersConcurrentClient::send_RenderHandler_GetScreenPoint(const int32_t bid, const int32_t viewX, const int32_t viewY)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RenderHandler_GetScreenPoint", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RenderHandler_GetScreenPoint_pargs args;
  args.bid = &bid;
  args.viewX = &viewX;
  args.viewY = &viewY;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ClientHandlersConcurrentClient::recv_RenderHandler_GetScreenPoint(Point& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("RenderHandler_GetScreenPoint") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ClientHandlers_RenderHandler_GetScreenPoint_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RenderHandler_GetScreenPoint failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::RenderHandler_OnPaint(const int32_t bid, const bool popup, const int32_t dirtyRectsCount, const std::string& sharedMemName, const int64_t sharedMemHandle, const int32_t width, const int32_t height)
{
  int32_t seqid = send_RenderHandler_OnPaint(bid, popup, dirtyRectsCount, sharedMemName, sharedMemHandle, width, height);
  recv_RenderHandler_OnPaint(seqid);
}

int32_t ClientHandlersConcurrentClient::send_RenderHandler_OnPaint(const int32_t bid, const bool popup, const int32_t dirtyRectsCount, const std::string& sharedMemName, const int64_t sharedMemHandle, const int32_t width, const int32_t height)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RenderHandler_OnPaint", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RenderHandler_OnPaint_pargs args;
  args.bid = &bid;
  args.popup = &popup;
  args.dirtyRectsCount = &dirtyRectsCount;
  args.sharedMemName = &sharedMemName;
  args.sharedMemHandle = &sharedMemHandle;
  args.width = &width;
  args.height = &height;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ClientHandlersConcurrentClient::recv_RenderHandler_OnPaint(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("RenderHandler_OnPaint") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ClientHandlers_RenderHandler_OnPaint_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ClientHandlersConcurrentClient::LifeSpanHandler_OnBeforePopup(const int32_t bid, const std::string& url, const std::string& frameName, const bool gesture)
{
  int32_t seqid = send_LifeSpanHandler_OnBeforePopup(bid, url, frameName, gesture);
  return recv_LifeSpanHandler_OnBeforePopup(seqid);
}

int32_t ClientHandlersConcurrentClient::send_LifeSpanHandler_OnBeforePopup(const int32_t bid, const std::string& url, const std::string& frameName, const bool gesture)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("LifeSpanHandler_OnBeforePopup", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_LifeSpanHandler_OnBeforePopup_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.frameName = &frameName;
  args.gesture = &gesture;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_LifeSpanHandler_OnBeforePopup(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("LifeSpanHandler_OnBeforePopup") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_LifeSpanHandler_OnBeforePopup_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "LifeSpanHandler_OnBeforePopup failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::LifeSpanHandler_OnAfterCreated(const int32_t bid)
{
  send_LifeSpanHandler_OnAfterCreated(bid);
}

void ClientHandlersConcurrentClient::send_LifeSpanHandler_OnAfterCreated(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("LifeSpanHandler_OnAfterCreated", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LifeSpanHandler_OnAfterCreated_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

bool ClientHandlersConcurrentClient::LifeSpanHandler_DoClose(const int32_t bid)
{
  int32_t seqid = send_LifeSpanHandler_DoClose(bid);
  return recv_LifeSpanHandler_DoClose(seqid);
}

int32_t ClientHandlersConcurrentClient::send_LifeSpanHandler_DoClose(const int32_t bid)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("LifeSpanHandler_DoClose", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_LifeSpanHandler_DoClose_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_LifeSpanHandler_DoClose(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("LifeSpanHandler_DoClose") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_LifeSpanHandler_DoClose_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "LifeSpanHandler_DoClose failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::LifeSpanHandler_OnBeforeClose(const int32_t bid)
{
  send_LifeSpanHandler_OnBeforeClose(bid);
}

void ClientHandlersConcurrentClient::send_LifeSpanHandler_OnBeforeClose(const int32_t bid)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("LifeSpanHandler_OnBeforeClose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LifeSpanHandler_OnBeforeClose_pargs args;
  args.bid = &bid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ClientHandlersConcurrentClient::LoadHandler_OnLoadingStateChange(const int32_t bid, const bool isLoading, const bool canGoBack, const bool canGoForward)
{
  send_LoadHandler_OnLoadingStateChange(bid, isLoading, canGoBack, canGoForward);
}

void ClientHandlersConcurrentClient::send_LoadHandler_OnLoadingStateChange(const int32_t bid, const bool isLoading, const bool canGoBack, const bool canGoForward)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("LoadHandler_OnLoadingStateChange", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LoadHandler_OnLoadingStateChange_pargs args;
  args.bid = &bid;
  args.isLoading = &isLoading;
  args.canGoBack = &canGoBack;
  args.canGoForward = &canGoForward;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ClientHandlersConcurrentClient::LoadHandler_OnLoadStart(const int32_t bid, const int32_t transition_type)
{
  send_LoadHandler_OnLoadStart(bid, transition_type);
}

void ClientHandlersConcurrentClient::send_LoadHandler_OnLoadStart(const int32_t bid, const int32_t transition_type)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("LoadHandler_OnLoadStart", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LoadHandler_OnLoadStart_pargs args;
  args.bid = &bid;
  args.transition_type = &transition_type;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ClientHandlersConcurrentClient::LoadHandler_OnLoadEnd(const int32_t bid, const int32_t httpStatusCode)
{
  send_LoadHandler_OnLoadEnd(bid, httpStatusCode);
}

void ClientHandlersConcurrentClient::send_LoadHandler_OnLoadEnd(const int32_t bid, const int32_t httpStatusCode)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("LoadHandler_OnLoadEnd", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LoadHandler_OnLoadEnd_pargs args;
  args.bid = &bid;
  args.httpStatusCode = &httpStatusCode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ClientHandlersConcurrentClient::LoadHandler_OnLoadError(const int32_t bid, const int32_t errorCode, const std::string& errorText, const std::string& failedUrl)
{
  send_LoadHandler_OnLoadError(bid, errorCode, errorText, failedUrl);
}

void ClientHandlersConcurrentClient::send_LoadHandler_OnLoadError(const int32_t bid, const int32_t errorCode, const std::string& errorText, const std::string& failedUrl)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("LoadHandler_OnLoadError", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_LoadHandler_OnLoadError_pargs args;
  args.bid = &bid;
  args.errorCode = &errorCode;
  args.errorText = &errorText;
  args.failedUrl = &failedUrl;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ClientHandlersConcurrentClient::DisplayHandler_OnAddressChange(const int32_t bid, const std::string& url)
{
  send_DisplayHandler_OnAddressChange(bid, url);
}

void ClientHandlersConcurrentClient::send_DisplayHandler_OnAddressChange(const int32_t bid, const std::string& url)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DisplayHandler_OnAddressChange", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_DisplayHandler_OnAddressChange_pargs args;
  args.bid = &bid;
  args.url = &url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ClientHandlersConcurrentClient::DisplayHandler_OnTitleChange(const int32_t bid, const std::string& title)
{
  send_DisplayHandler_OnTitleChange(bid, title);
}

void ClientHandlersConcurrentClient::send_DisplayHandler_OnTitleChange(const int32_t bid, const std::string& title)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DisplayHandler_OnTitleChange", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_DisplayHandler_OnTitleChange_pargs args;
  args.bid = &bid;
  args.title = &title;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

bool ClientHandlersConcurrentClient::DisplayHandler_OnTooltip(const int32_t bid, const std::string& text)
{
  int32_t seqid = send_DisplayHandler_OnTooltip(bid, text);
  return recv_DisplayHandler_OnTooltip(seqid);
}

int32_t ClientHandlersConcurrentClient::send_DisplayHandler_OnTooltip(const int32_t bid, const std::string& text)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DisplayHandler_OnTooltip", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_DisplayHandler_OnTooltip_pargs args;
  args.bid = &bid;
  args.text = &text;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_DisplayHandler_OnTooltip(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DisplayHandler_OnTooltip") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_DisplayHandler_OnTooltip_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DisplayHandler_OnTooltip failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::DisplayHandler_OnStatusMessage(const int32_t bid, const std::string& value)
{
  send_DisplayHandler_OnStatusMessage(bid, value);
}

void ClientHandlersConcurrentClient::send_DisplayHandler_OnStatusMessage(const int32_t bid, const std::string& value)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DisplayHandler_OnStatusMessage", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_DisplayHandler_OnStatusMessage_pargs args;
  args.bid = &bid;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

bool ClientHandlersConcurrentClient::DisplayHandler_OnConsoleMessage(const int32_t bid, const int32_t level, const std::string& message, const std::string& source, const int32_t line)
{
  int32_t seqid = send_DisplayHandler_OnConsoleMessage(bid, level, message, source, line);
  return recv_DisplayHandler_OnConsoleMessage(seqid);
}

int32_t ClientHandlersConcurrentClient::send_DisplayHandler_OnConsoleMessage(const int32_t bid, const int32_t level, const std::string& message, const std::string& source, const int32_t line)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DisplayHandler_OnConsoleMessage", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_DisplayHandler_OnConsoleMessage_pargs args;
  args.bid = &bid;
  args.level = &level;
  args.message = &message;
  args.source = &source;
  args.line = &line;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_DisplayHandler_OnConsoleMessage(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DisplayHandler_OnConsoleMessage") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_DisplayHandler_OnConsoleMessage_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DisplayHandler_OnConsoleMessage failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ClientHandlersConcurrentClient::RequestHandler_OnBeforeBrowse(const int32_t bid, const  ::thrift_codegen::RObject& request, const bool user_gesture, const bool is_redirect)
{
  int32_t seqid = send_RequestHandler_OnBeforeBrowse(bid, request, user_gesture, is_redirect);
  return recv_RequestHandler_OnBeforeBrowse(seqid);
}

int32_t ClientHandlersConcurrentClient::send_RequestHandler_OnBeforeBrowse(const int32_t bid, const  ::thrift_codegen::RObject& request, const bool user_gesture, const bool is_redirect)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RequestHandler_OnBeforeBrowse", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RequestHandler_OnBeforeBrowse_pargs args;
  args.bid = &bid;
  args.request = &request;
  args.user_gesture = &user_gesture;
  args.is_redirect = &is_redirect;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_RequestHandler_OnBeforeBrowse(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("RequestHandler_OnBeforeBrowse") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_RequestHandler_OnBeforeBrowse_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RequestHandler_OnBeforeBrowse failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ClientHandlersConcurrentClient::RequestHandler_OnOpenURLFromTab(const int32_t bid, const std::string& target_url, const bool user_gesture)
{
  int32_t seqid = send_RequestHandler_OnOpenURLFromTab(bid, target_url, user_gesture);
  return recv_RequestHandler_OnOpenURLFromTab(seqid);
}

int32_t ClientHandlersConcurrentClient::send_RequestHandler_OnOpenURLFromTab(const int32_t bid, const std::string& target_url, const bool user_gesture)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RequestHandler_OnOpenURLFromTab", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RequestHandler_OnOpenURLFromTab_pargs args;
  args.bid = &bid;
  args.target_url = &target_url;
  args.user_gesture = &user_gesture;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_RequestHandler_OnOpenURLFromTab(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("RequestHandler_OnOpenURLFromTab") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_RequestHandler_OnOpenURLFromTab_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RequestHandler_OnOpenURLFromTab failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ClientHandlersConcurrentClient::RequestHandler_GetAuthCredentials(const int32_t bid, const std::string& origin_url, const bool isProxy, const std::string& host, const int32_t port, const std::string& realm, const std::string& scheme, const  ::thrift_codegen::RObject& authCallback)
{
  int32_t seqid = send_RequestHandler_GetAuthCredentials(bid, origin_url, isProxy, host, port, realm, scheme, authCallback);
  return recv_RequestHandler_GetAuthCredentials(seqid);
}

int32_t ClientHandlersConcurrentClient::send_RequestHandler_GetAuthCredentials(const int32_t bid, const std::string& origin_url, const bool isProxy, const std::string& host, const int32_t port, const std::string& realm, const std::string& scheme, const  ::thrift_codegen::RObject& authCallback)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RequestHandler_GetAuthCredentials", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RequestHandler_GetAuthCredentials_pargs args;
  args.bid = &bid;
  args.origin_url = &origin_url;
  args.isProxy = &isProxy;
  args.host = &host;
  args.port = &port;
  args.realm = &realm;
  args.scheme = &scheme;
  args.authCallback = &authCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_RequestHandler_GetAuthCredentials(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("RequestHandler_GetAuthCredentials") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_RequestHandler_GetAuthCredentials_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RequestHandler_GetAuthCredentials failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ClientHandlersConcurrentClient::RequestHandler_OnCertificateError(const int32_t bid, const std::string& cert_error, const std::string& request_url, const  ::thrift_codegen::RObject& sslInfo, const  ::thrift_codegen::RObject& callback)
{
  int32_t seqid = send_RequestHandler_OnCertificateError(bid, cert_error, request_url, sslInfo, callback);
  return recv_RequestHandler_OnCertificateError(seqid);
}

int32_t ClientHandlersConcurrentClient::send_RequestHandler_OnCertificateError(const int32_t bid, const std::string& cert_error, const std::string& request_url, const  ::thrift_codegen::RObject& sslInfo, const  ::thrift_codegen::RObject& callback)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RequestHandler_OnCertificateError", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RequestHandler_OnCertificateError_pargs args;
  args.bid = &bid;
  args.cert_error = &cert_error;
  args.request_url = &request_url;
  args.sslInfo = &sslInfo;
  args.callback = &callback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_RequestHandler_OnCertificateError(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("RequestHandler_OnCertificateError") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_RequestHandler_OnCertificateError_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RequestHandler_OnCertificateError failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::RequestHandler_OnRenderProcessTerminated(const int32_t bid, const std::string& status)
{
  send_RequestHandler_OnRenderProcessTerminated(bid, status);
}

void ClientHandlersConcurrentClient::send_RequestHandler_OnRenderProcessTerminated(const int32_t bid, const std::string& status)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RequestHandler_OnRenderProcessTerminated", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_RequestHandler_OnRenderProcessTerminated_pargs args;
  args.bid = &bid;
  args.status = &status;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ClientHandlersConcurrentClient::RequestHandler_GetResourceRequestHandler( ::thrift_codegen::RObject& _return, const int32_t bid, const  ::thrift_codegen::RObject& request, const bool isNavigation, const bool isDownload, const std::string& requestInitiator)
{
  int32_t seqid = send_RequestHandler_GetResourceRequestHandler(bid, request, isNavigation, isDownload, requestInitiator);
  recv_RequestHandler_GetResourceRequestHandler(_return, seqid);
}

int32_t ClientHandlersConcurrentClient::send_RequestHandler_GetResourceRequestHandler(const int32_t bid, const  ::thrift_codegen::RObject& request, const bool isNavigation, const bool isDownload, const std::string& requestInitiator)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RequestHandler_GetResourceRequestHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_RequestHandler_GetResourceRequestHandler_pargs args;
  args.bid = &bid;
  args.request = &request;
  args.isNavigation = &isNavigation;
  args.isDownload = &isDownload;
  args.requestInitiator = &requestInitiator;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ClientHandlersConcurrentClient::recv_RequestHandler_GetResourceRequestHandler( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("RequestHandler_GetResourceRequestHandler") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ClientHandlers_RequestHandler_GetResourceRequestHandler_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RequestHandler_GetResourceRequestHandler failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::ResourceRequestHandler_Dispose(const int32_t rrHandler)
{
  send_ResourceRequestHandler_Dispose(rrHandler);
}

void ClientHandlersConcurrentClient::send_ResourceRequestHandler_Dispose(const int32_t rrHandler)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("ResourceRequestHandler_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_ResourceRequestHandler_Dispose_pargs args;
  args.rrHandler = &rrHandler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ClientHandlersConcurrentClient::ResourceRequestHandler_GetCookieAccessFilter( ::thrift_codegen::RObject& _return, const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  int32_t seqid = send_ResourceRequestHandler_GetCookieAccessFilter(rrHandler, bid, request);
  recv_ResourceRequestHandler_GetCookieAccessFilter(_return, seqid);
}

int32_t ClientHandlersConcurrentClient::send_ResourceRequestHandler_GetCookieAccessFilter(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("ResourceRequestHandler_GetCookieAccessFilter", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ClientHandlersConcurrentClient::recv_ResourceRequestHandler_GetCookieAccessFilter( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("ResourceRequestHandler_GetCookieAccessFilter") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ClientHandlers_ResourceRequestHandler_GetCookieAccessFilter_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_GetCookieAccessFilter failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::CookieAccessFilter_Dispose(const int32_t filter)
{
  send_CookieAccessFilter_Dispose(filter);
}

void ClientHandlersConcurrentClient::send_CookieAccessFilter_Dispose(const int32_t filter)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("CookieAccessFilter_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_CookieAccessFilter_Dispose_pargs args;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

bool ClientHandlersConcurrentClient::CookieAccessFilter_CanSendCookie(const int32_t filter, const int32_t bid, const  ::thrift_codegen::RObject& request, const std::vector<std::string> & cookie)
{
  int32_t seqid = send_CookieAccessFilter_CanSendCookie(filter, bid, request, cookie);
  return recv_CookieAccessFilter_CanSendCookie(seqid);
}

int32_t ClientHandlersConcurrentClient::send_CookieAccessFilter_CanSendCookie(const int32_t filter, const int32_t bid, const  ::thrift_codegen::RObject& request, const std::vector<std::string> & cookie)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("CookieAccessFilter_CanSendCookie", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_CookieAccessFilter_CanSendCookie_pargs args;
  args.filter = &filter;
  args.bid = &bid;
  args.request = &request;
  args.cookie = &cookie;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_CookieAccessFilter_CanSendCookie(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("CookieAccessFilter_CanSendCookie") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_CookieAccessFilter_CanSendCookie_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieAccessFilter_CanSendCookie failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ClientHandlersConcurrentClient::CookieAccessFilter_CanSaveCookie(const int32_t filter, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::vector<std::string> & cookie)
{
  int32_t seqid = send_CookieAccessFilter_CanSaveCookie(filter, bid, request, response, cookie);
  return recv_CookieAccessFilter_CanSaveCookie(seqid);
}

int32_t ClientHandlersConcurrentClient::send_CookieAccessFilter_CanSaveCookie(const int32_t filter, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::vector<std::string> & cookie)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("CookieAccessFilter_CanSaveCookie", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_CookieAccessFilter_CanSaveCookie_pargs args;
  args.filter = &filter;
  args.bid = &bid;
  args.request = &request;
  args.response = &response;
  args.cookie = &cookie;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_CookieAccessFilter_CanSaveCookie(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("CookieAccessFilter_CanSaveCookie") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_CookieAccessFilter_CanSaveCookie_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CookieAccessFilter_CanSaveCookie failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ClientHandlersConcurrentClient::ResourceRequestHandler_OnBeforeResourceLoad(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  int32_t seqid = send_ResourceRequestHandler_OnBeforeResourceLoad(rrHandler, bid, request);
  return recv_ResourceRequestHandler_OnBeforeResourceLoad(seqid);
}

int32_t ClientHandlersConcurrentClient::send_ResourceRequestHandler_OnBeforeResourceLoad(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("ResourceRequestHandler_OnBeforeResourceLoad", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_ResourceRequestHandler_OnBeforeResourceLoad(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("ResourceRequestHandler_OnBeforeResourceLoad") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_ResourceRequestHandler_OnBeforeResourceLoad_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_OnBeforeResourceLoad failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::ResourceRequestHandler_GetResourceHandler( ::thrift_codegen::RObject& _return, const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  int32_t seqid = send_ResourceRequestHandler_GetResourceHandler(rrHandler, bid, request);
  recv_ResourceRequestHandler_GetResourceHandler(_return, seqid);
}

int32_t ClientHandlersConcurrentClient::send_ResourceRequestHandler_GetResourceHandler(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("ResourceRequestHandler_GetResourceHandler", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_GetResourceHandler_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ClientHandlersConcurrentClient::recv_ResourceRequestHandler_GetResourceHandler( ::thrift_codegen::RObject& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("ResourceRequestHandler_GetResourceHandler") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ClientHandlers_ResourceRequestHandler_GetResourceHandler_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_GetResourceHandler failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::ResourceHandler_Dispose(const int32_t resourceHandler)
{
  send_ResourceHandler_Dispose(resourceHandler);
}

void ClientHandlersConcurrentClient::send_ResourceHandler_Dispose(const int32_t resourceHandler)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("ResourceHandler_Dispose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_ResourceHandler_Dispose_pargs args;
  args.resourceHandler = &resourceHandler;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void ClientHandlersConcurrentClient::ResourceRequestHandler_OnResourceRedirect(std::string& _return, const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::string& new_url)
{
  int32_t seqid = send_ResourceRequestHandler_OnResourceRedirect(rrHandler, bid, request, response, new_url);
  recv_ResourceRequestHandler_OnResourceRedirect(_return, seqid);
}

int32_t ClientHandlersConcurrentClient::send_ResourceRequestHandler_OnResourceRedirect(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::string& new_url)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("ResourceRequestHandler_OnResourceRedirect", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_OnResourceRedirect_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.response = &response;
  args.new_url = &new_url;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void ClientHandlersConcurrentClient::recv_ResourceRequestHandler_OnResourceRedirect(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("ResourceRequestHandler_OnResourceRedirect") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      ClientHandlers_ResourceRequestHandler_OnResourceRedirect_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_OnResourceRedirect failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ClientHandlersConcurrentClient::ResourceRequestHandler_OnResourceResponse(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response)
{
  int32_t seqid = send_ResourceRequestHandler_OnResourceResponse(rrHandler, bid, request, response);
  return recv_ResourceRequestHandler_OnResourceResponse(seqid);
}

int32_t ClientHandlersConcurrentClient::send_ResourceRequestHandler_OnResourceResponse(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("ResourceRequestHandler_OnResourceResponse", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_OnResourceResponse_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.response = &response;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_ResourceRequestHandler_OnResourceResponse(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("ResourceRequestHandler_OnResourceResponse") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_ResourceRequestHandler_OnResourceResponse_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_OnResourceResponse failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::ResourceRequestHandler_OnResourceLoadComplete(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::string& status, const int64_t receivedContentLength)
{
  send_ResourceRequestHandler_OnResourceLoadComplete(rrHandler, bid, request, response, status, receivedContentLength);
}

void ClientHandlersConcurrentClient::send_ResourceRequestHandler_OnResourceLoadComplete(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const  ::thrift_codegen::RObject& response, const std::string& status, const int64_t receivedContentLength)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("ResourceRequestHandler_OnResourceLoadComplete", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_ResourceRequestHandler_OnResourceLoadComplete_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.response = &response;
  args.status = &status;
  args.receivedContentLength = &receivedContentLength;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

bool ClientHandlersConcurrentClient::ResourceRequestHandler_OnProtocolExecution(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const bool allowOsExecution)
{
  int32_t seqid = send_ResourceRequestHandler_OnProtocolExecution(rrHandler, bid, request, allowOsExecution);
  return recv_ResourceRequestHandler_OnProtocolExecution(seqid);
}

int32_t ClientHandlersConcurrentClient::send_ResourceRequestHandler_OnProtocolExecution(const int32_t rrHandler, const int32_t bid, const  ::thrift_codegen::RObject& request, const bool allowOsExecution)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("ResourceRequestHandler_OnProtocolExecution", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_ResourceRequestHandler_OnProtocolExecution_pargs args;
  args.rrHandler = &rrHandler;
  args.bid = &bid;
  args.request = &request;
  args.allowOsExecution = &allowOsExecution;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_ResourceRequestHandler_OnProtocolExecution(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("ResourceRequestHandler_OnProtocolExecution") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_ResourceRequestHandler_OnProtocolExecution_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ResourceRequestHandler_OnProtocolExecution failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool ClientHandlersConcurrentClient::MessageRouterHandler_onQuery(const  ::thrift_codegen::RObject& handler, const int32_t bid, const int64_t queryId, const std::string& request, const bool persistent, const  ::thrift_codegen::RObject& queryCallback)
{
  int32_t seqid = send_MessageRouterHandler_onQuery(handler, bid, queryId, request, persistent, queryCallback);
  return recv_MessageRouterHandler_onQuery(seqid);
}

int32_t ClientHandlersConcurrentClient::send_MessageRouterHandler_onQuery(const  ::thrift_codegen::RObject& handler, const int32_t bid, const int64_t queryId, const std::string& request, const bool persistent, const  ::thrift_codegen::RObject& queryCallback)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouterHandler_onQuery", ::apache::thrift::protocol::T_CALL, cseqid);

  ClientHandlers_MessageRouterHandler_onQuery_pargs args;
  args.handler = &handler;
  args.bid = &bid;
  args.queryId = &queryId;
  args.request = &request;
  args.persistent = &persistent;
  args.queryCallback = &queryCallback;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool ClientHandlersConcurrentClient::recv_MessageRouterHandler_onQuery(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MessageRouterHandler_onQuery") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      ClientHandlers_MessageRouterHandler_onQuery_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MessageRouterHandler_onQuery failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void ClientHandlersConcurrentClient::MessageRouterHandler_onQueryCanceled(const  ::thrift_codegen::RObject& handler, const int32_t bid, const int64_t queryId)
{
  send_MessageRouterHandler_onQueryCanceled(handler, bid, queryId);
}

void ClientHandlersConcurrentClient::send_MessageRouterHandler_onQueryCanceled(const  ::thrift_codegen::RObject& handler, const int32_t bid, const int64_t queryId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MessageRouterHandler_onQueryCanceled", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  ClientHandlers_MessageRouterHandler_onQueryCanceled_pargs args;
  args.handler = &handler;
  args.bid = &bid;
  args.queryId = &queryId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

} // namespace

