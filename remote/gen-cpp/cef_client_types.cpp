/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "cef_client_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace thrift_codegen {


CustomScheme::~CustomScheme() noexcept {
}


void CustomScheme::__set_schemeName(const std::string& val) {
  this->schemeName = val;
}

void CustomScheme::__set_options(const int32_t val) {
  this->options = val;
}
std::ostream& operator<<(std::ostream& out, const CustomScheme& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CustomScheme::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_schemeName = false;
  bool isset_options = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemeName);
          isset_schemeName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->options);
          isset_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_schemeName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_options)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CustomScheme::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CustomScheme");

  xfer += oprot->writeFieldBegin("schemeName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->schemeName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->options);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CustomScheme &a, CustomScheme &b) {
  using ::std::swap;
  swap(a.schemeName, b.schemeName);
  swap(a.options, b.options);
}

CustomScheme::CustomScheme(const CustomScheme& other0) {
  schemeName = other0.schemeName;
  options = other0.options;
}
CustomScheme& CustomScheme::operator=(const CustomScheme& other1) {
  schemeName = other1.schemeName;
  options = other1.options;
  return *this;
}
void CustomScheme::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CustomScheme(";
  out << "schemeName=" << to_string(schemeName);
  out << ", " << "options=" << to_string(options);
  out << ")";
}


Point::~Point() noexcept {
}


void Point::__set_x(const int32_t val) {
  this->x = val;
}

void Point::__set_y(const int32_t val) {
  this->y = val;
}
std::ostream& operator<<(std::ostream& out, const Point& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Point::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_x = false;
  bool isset_y = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          isset_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          isset_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_x)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_y)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Point::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Point");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Point &a, Point &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
}

Point::Point(const Point& other2) noexcept {
  x = other2.x;
  y = other2.y;
}
Point& Point::operator=(const Point& other3) noexcept {
  x = other3.x;
  y = other3.y;
  return *this;
}
void Point::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Point(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ")";
}


Rect::~Rect() noexcept {
}


void Rect::__set_x(const int32_t val) {
  this->x = val;
}

void Rect::__set_y(const int32_t val) {
  this->y = val;
}

void Rect::__set_w(const int32_t val) {
  this->w = val;
}

void Rect::__set_h(const int32_t val) {
  this->h = val;
}
std::ostream& operator<<(std::ostream& out, const Rect& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Rect::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_x = false;
  bool isset_y = false;
  bool isset_w = false;
  bool isset_h = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          isset_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          isset_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->w);
          isset_w = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->h);
          isset_h = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_x)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_y)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_w)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_h)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Rect::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Rect");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("w", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->w);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("h", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->h);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Rect &a, Rect &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.w, b.w);
  swap(a.h, b.h);
}

Rect::Rect(const Rect& other4) noexcept {
  x = other4.x;
  y = other4.y;
  w = other4.w;
  h = other4.h;
}
Rect& Rect::operator=(const Rect& other5) noexcept {
  x = other5.x;
  y = other5.y;
  w = other5.w;
  h = other5.h;
  return *this;
}
void Rect::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Rect(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "w=" << to_string(w);
  out << ", " << "h=" << to_string(h);
  out << ")";
}


ScreenInfo::~ScreenInfo() noexcept {
}


void ScreenInfo::__set_device_scale_factor(const double val) {
  this->device_scale_factor = val;
}

void ScreenInfo::__set_depth(const int32_t val) {
  this->depth = val;
}

void ScreenInfo::__set_depth_per_component(const int32_t val) {
  this->depth_per_component = val;
}

void ScreenInfo::__set_is_monochrome(const bool val) {
  this->is_monochrome = val;
}

void ScreenInfo::__set_rect(const Rect& val) {
  this->rect = val;
}

void ScreenInfo::__set_available_rect(const Rect& val) {
  this->available_rect = val;
}
std::ostream& operator<<(std::ostream& out, const ScreenInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScreenInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_device_scale_factor = false;
  bool isset_depth = false;
  bool isset_depth_per_component = false;
  bool isset_is_monochrome = false;
  bool isset_rect = false;
  bool isset_available_rect = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->device_scale_factor);
          isset_device_scale_factor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->depth);
          isset_depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->depth_per_component);
          isset_depth_per_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_monochrome);
          isset_is_monochrome = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rect.read(iprot);
          isset_rect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->available_rect.read(iprot);
          isset_available_rect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_device_scale_factor)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_depth)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_depth_per_component)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_monochrome)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_rect)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_available_rect)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScreenInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScreenInfo");

  xfer += oprot->writeFieldBegin("device_scale_factor", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->device_scale_factor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("depth", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->depth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("depth_per_component", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->depth_per_component);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_monochrome", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_monochrome);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rect", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->rect.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("available_rect", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->available_rect.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScreenInfo &a, ScreenInfo &b) {
  using ::std::swap;
  swap(a.device_scale_factor, b.device_scale_factor);
  swap(a.depth, b.depth);
  swap(a.depth_per_component, b.depth_per_component);
  swap(a.is_monochrome, b.is_monochrome);
  swap(a.rect, b.rect);
  swap(a.available_rect, b.available_rect);
}

ScreenInfo::ScreenInfo(const ScreenInfo& other6) noexcept {
  device_scale_factor = other6.device_scale_factor;
  depth = other6.depth;
  depth_per_component = other6.depth_per_component;
  is_monochrome = other6.is_monochrome;
  rect = other6.rect;
  available_rect = other6.available_rect;
}
ScreenInfo& ScreenInfo::operator=(const ScreenInfo& other7) noexcept {
  device_scale_factor = other7.device_scale_factor;
  depth = other7.depth;
  depth_per_component = other7.depth_per_component;
  is_monochrome = other7.is_monochrome;
  rect = other7.rect;
  available_rect = other7.available_rect;
  return *this;
}
void ScreenInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScreenInfo(";
  out << "device_scale_factor=" << to_string(device_scale_factor);
  out << ", " << "depth=" << to_string(depth);
  out << ", " << "depth_per_component=" << to_string(depth_per_component);
  out << ", " << "is_monochrome=" << to_string(is_monochrome);
  out << ", " << "rect=" << to_string(rect);
  out << ", " << "available_rect=" << to_string(available_rect);
  out << ")";
}

} // namespace
