/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "shared_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace thrift_codegen {


RObject::~RObject() noexcept {
}


void RObject::__set_objId(const int32_t val) {
  this->objId = val;
}

void RObject::__set_isPersistent(const bool val) {
  this->isPersistent = val;
__isset.isPersistent = true;
}

void RObject::__set_isDisableDefaultHandling(const bool val) {
  this->isDisableDefaultHandling = val;
__isset.isDisableDefaultHandling = true;
}

void RObject::__set_objInfo(const std::map<std::string, std::string> & val) {
  this->objInfo = val;
__isset.objInfo = true;
}
std::ostream& operator<<(std::ostream& out, const RObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_objId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->objId);
          isset_objId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isPersistent);
          this->__isset.isPersistent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isDisableDefaultHandling);
          this->__isset.isDisableDefaultHandling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->objInfo.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              std::string& _val6 = this->objInfo[_key5];
              xfer += iprot->readString(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.objInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_objId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RObject");

  xfer += oprot->writeFieldBegin("objId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->objId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.isPersistent) {
    xfer += oprot->writeFieldBegin("isPersistent", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->isPersistent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.isDisableDefaultHandling) {
    xfer += oprot->writeFieldBegin("isDisableDefaultHandling", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->isDisableDefaultHandling);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.objInfo) {
    xfer += oprot->writeFieldBegin("objInfo", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->objInfo.size()));
      std::map<std::string, std::string> ::const_iterator _iter7;
      for (_iter7 = this->objInfo.begin(); _iter7 != this->objInfo.end(); ++_iter7)
      {
        xfer += oprot->writeString(_iter7->first);
        xfer += oprot->writeString(_iter7->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RObject &a, RObject &b) {
  using ::std::swap;
  swap(a.objId, b.objId);
  swap(a.isPersistent, b.isPersistent);
  swap(a.isDisableDefaultHandling, b.isDisableDefaultHandling);
  swap(a.objInfo, b.objInfo);
  swap(a.__isset, b.__isset);
}

RObject::RObject(const RObject& other8) {
  objId = other8.objId;
  isPersistent = other8.isPersistent;
  isDisableDefaultHandling = other8.isDisableDefaultHandling;
  objInfo = other8.objInfo;
  __isset = other8.__isset;
}
RObject& RObject::operator=(const RObject& other9) {
  objId = other9.objId;
  isPersistent = other9.isPersistent;
  isDisableDefaultHandling = other9.isDisableDefaultHandling;
  objInfo = other9.objInfo;
  __isset = other9.__isset;
  return *this;
}
void RObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RObject(";
  out << "objId=" << to_string(objId);
  out << ", " << "isPersistent="; (__isset.isPersistent ? (out << to_string(isPersistent)) : (out << "<null>"));
  out << ", " << "isDisableDefaultHandling="; (__isset.isDisableDefaultHandling ? (out << to_string(isDisableDefaultHandling)) : (out << "<null>"));
  out << ", " << "objInfo="; (__isset.objInfo ? (out << to_string(objInfo)) : (out << "<null>"));
  out << ")";
}


PostDataElement::~PostDataElement() noexcept {
}


void PostDataElement::__set_isReadOnly(const bool val) {
  this->isReadOnly = val;
}

void PostDataElement::__set_file(const std::string& val) {
  this->file = val;
__isset.file = true;
}

void PostDataElement::__set_bytes(const std::string& val) {
  this->bytes = val;
__isset.bytes = true;
}
std::ostream& operator<<(std::ostream& out, const PostDataElement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PostDataElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isReadOnly = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isReadOnly);
          isset_isReadOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file);
          this->__isset.file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bytes);
          this->__isset.bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isReadOnly)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PostDataElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PostDataElement");

  xfer += oprot->writeFieldBegin("isReadOnly", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isReadOnly);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.file) {
    xfer += oprot->writeFieldBegin("file", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->file);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bytes) {
    xfer += oprot->writeFieldBegin("bytes", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->bytes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PostDataElement &a, PostDataElement &b) {
  using ::std::swap;
  swap(a.isReadOnly, b.isReadOnly);
  swap(a.file, b.file);
  swap(a.bytes, b.bytes);
  swap(a.__isset, b.__isset);
}

PostDataElement::PostDataElement(const PostDataElement& other10) {
  isReadOnly = other10.isReadOnly;
  file = other10.file;
  bytes = other10.bytes;
  __isset = other10.__isset;
}
PostDataElement& PostDataElement::operator=(const PostDataElement& other11) {
  isReadOnly = other11.isReadOnly;
  file = other11.file;
  bytes = other11.bytes;
  __isset = other11.__isset;
  return *this;
}
void PostDataElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PostDataElement(";
  out << "isReadOnly=" << to_string(isReadOnly);
  out << ", " << "file="; (__isset.file ? (out << to_string(file)) : (out << "<null>"));
  out << ", " << "bytes="; (__isset.bytes ? (out << to_string(bytes)) : (out << "<null>"));
  out << ")";
}


PostData::~PostData() noexcept {
}


void PostData::__set_isReadOnly(const bool val) {
  this->isReadOnly = val;
}

void PostData::__set_hasExcludedElements(const bool val) {
  this->hasExcludedElements = val;
}

void PostData::__set_elements(const std::vector<PostDataElement> & val) {
  this->elements = val;
__isset.elements = true;
}
std::ostream& operator<<(std::ostream& out, const PostData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PostData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isReadOnly = false;
  bool isset_hasExcludedElements = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isReadOnly);
          isset_isReadOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasExcludedElements);
          isset_hasExcludedElements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->elements.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->elements.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->elements[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.elements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isReadOnly)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasExcludedElements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PostData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PostData");

  xfer += oprot->writeFieldBegin("isReadOnly", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isReadOnly);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasExcludedElements", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasExcludedElements);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.elements) {
    xfer += oprot->writeFieldBegin("elements", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->elements.size()));
      std::vector<PostDataElement> ::const_iterator _iter17;
      for (_iter17 = this->elements.begin(); _iter17 != this->elements.end(); ++_iter17)
      {
        xfer += (*_iter17).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PostData &a, PostData &b) {
  using ::std::swap;
  swap(a.isReadOnly, b.isReadOnly);
  swap(a.hasExcludedElements, b.hasExcludedElements);
  swap(a.elements, b.elements);
  swap(a.__isset, b.__isset);
}

PostData::PostData(const PostData& other18) {
  isReadOnly = other18.isReadOnly;
  hasExcludedElements = other18.hasExcludedElements;
  elements = other18.elements;
  __isset = other18.__isset;
}
PostData& PostData::operator=(const PostData& other19) {
  isReadOnly = other19.isReadOnly;
  hasExcludedElements = other19.hasExcludedElements;
  elements = other19.elements;
  __isset = other19.__isset;
  return *this;
}
void PostData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PostData(";
  out << "isReadOnly=" << to_string(isReadOnly);
  out << ", " << "hasExcludedElements=" << to_string(hasExcludedElements);
  out << ", " << "elements="; (__isset.elements ? (out << to_string(elements)) : (out << "<null>"));
  out << ")";
}

} // namespace
