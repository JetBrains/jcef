/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "shared_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace thrift_codegen {


RObject::~RObject() noexcept {
}


void RObject::__set_objId(const int32_t val) {
  this->objId = val;
}

void RObject::__set_flags(const int32_t val) {
  this->flags = val;
__isset.flags = true;
}

void RObject::__set_objInfo(const std::map<std::string, std::string> & val) {
  this->objInfo = val;
__isset.objInfo = true;
}
std::ostream& operator<<(std::ostream& out, const RObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_objId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->objId);
          isset_objId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->flags);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->objInfo.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              std::string& _val6 = this->objInfo[_key5];
              xfer += iprot->readString(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.objInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_objId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RObject");

  xfer += oprot->writeFieldBegin("objId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->objId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->flags);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.objInfo) {
    xfer += oprot->writeFieldBegin("objInfo", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->objInfo.size()));
      std::map<std::string, std::string> ::const_iterator _iter7;
      for (_iter7 = this->objInfo.begin(); _iter7 != this->objInfo.end(); ++_iter7)
      {
        xfer += oprot->writeString(_iter7->first);
        xfer += oprot->writeString(_iter7->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RObject &a, RObject &b) {
  using ::std::swap;
  swap(a.objId, b.objId);
  swap(a.flags, b.flags);
  swap(a.objInfo, b.objInfo);
  swap(a.__isset, b.__isset);
}

RObject::RObject(const RObject& other8) {
  objId = other8.objId;
  flags = other8.flags;
  objInfo = other8.objInfo;
  __isset = other8.__isset;
}
RObject& RObject::operator=(const RObject& other9) {
  objId = other9.objId;
  flags = other9.flags;
  objInfo = other9.objInfo;
  __isset = other9.__isset;
  return *this;
}
void RObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RObject(";
  out << "objId=" << to_string(objId);
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ", " << "objInfo="; (__isset.objInfo ? (out << to_string(objInfo)) : (out << "<null>"));
  out << ")";
}


ResponseHeaders::~ResponseHeaders() noexcept {
}


void ResponseHeaders::__set_length(const int32_t val) {
  this->length = val;
__isset.length = true;
}

void ResponseHeaders::__set_redirectUrl(const std::string& val) {
  this->redirectUrl = val;
__isset.redirectUrl = true;
}
std::ostream& operator<<(std::ostream& out, const ResponseHeaders& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResponseHeaders::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->redirectUrl);
          this->__isset.redirectUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResponseHeaders::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResponseHeaders");

  if (this->__isset.length) {
    xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->length);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.redirectUrl) {
    xfer += oprot->writeFieldBegin("redirectUrl", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->redirectUrl);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResponseHeaders &a, ResponseHeaders &b) {
  using ::std::swap;
  swap(a.length, b.length);
  swap(a.redirectUrl, b.redirectUrl);
  swap(a.__isset, b.__isset);
}

ResponseHeaders::ResponseHeaders(const ResponseHeaders& other10) {
  length = other10.length;
  redirectUrl = other10.redirectUrl;
  __isset = other10.__isset;
}
ResponseHeaders& ResponseHeaders::operator=(const ResponseHeaders& other11) {
  length = other11.length;
  redirectUrl = other11.redirectUrl;
  __isset = other11.__isset;
  return *this;
}
void ResponseHeaders::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResponseHeaders(";
  out << "length="; (__isset.length ? (out << to_string(length)) : (out << "<null>"));
  out << ", " << "redirectUrl="; (__isset.redirectUrl ? (out << to_string(redirectUrl)) : (out << "<null>"));
  out << ")";
}


ResponseData::~ResponseData() noexcept {
}


void ResponseData::__set_continueRead(const bool val) {
  this->continueRead = val;
__isset.continueRead = true;
}

void ResponseData::__set_data(const std::string& val) {
  this->data = val;
__isset.data = true;
}

void ResponseData::__set_bytes_read(const int32_t val) {
  this->bytes_read = val;
__isset.bytes_read = true;
}
std::ostream& operator<<(std::ostream& out, const ResponseData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ResponseData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->continueRead);
          this->__isset.continueRead = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bytes_read);
          this->__isset.bytes_read = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ResponseData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ResponseData");

  if (this->__isset.continueRead) {
    xfer += oprot->writeFieldBegin("continueRead", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->continueRead);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data) {
    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->data);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bytes_read) {
    xfer += oprot->writeFieldBegin("bytes_read", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->bytes_read);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ResponseData &a, ResponseData &b) {
  using ::std::swap;
  swap(a.continueRead, b.continueRead);
  swap(a.data, b.data);
  swap(a.bytes_read, b.bytes_read);
  swap(a.__isset, b.__isset);
}

ResponseData::ResponseData(const ResponseData& other12) {
  continueRead = other12.continueRead;
  data = other12.data;
  bytes_read = other12.bytes_read;
  __isset = other12.__isset;
}
ResponseData& ResponseData::operator=(const ResponseData& other13) {
  continueRead = other13.continueRead;
  data = other13.data;
  bytes_read = other13.bytes_read;
  __isset = other13.__isset;
  return *this;
}
void ResponseData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ResponseData(";
  out << "continueRead="; (__isset.continueRead ? (out << to_string(continueRead)) : (out << "<null>"));
  out << ", " << "data="; (__isset.data ? (out << to_string(data)) : (out << "<null>"));
  out << ", " << "bytes_read="; (__isset.bytes_read ? (out << to_string(bytes_read)) : (out << "<null>"));
  out << ")";
}


PostDataElement::~PostDataElement() noexcept {
}


void PostDataElement::__set_isReadOnly(const bool val) {
  this->isReadOnly = val;
}

void PostDataElement::__set_file(const std::string& val) {
  this->file = val;
__isset.file = true;
}

void PostDataElement::__set_bytes(const std::string& val) {
  this->bytes = val;
__isset.bytes = true;
}
std::ostream& operator<<(std::ostream& out, const PostDataElement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PostDataElement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isReadOnly = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isReadOnly);
          isset_isReadOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file);
          this->__isset.file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bytes);
          this->__isset.bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isReadOnly)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PostDataElement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PostDataElement");

  xfer += oprot->writeFieldBegin("isReadOnly", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isReadOnly);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.file) {
    xfer += oprot->writeFieldBegin("file", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->file);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bytes) {
    xfer += oprot->writeFieldBegin("bytes", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->bytes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PostDataElement &a, PostDataElement &b) {
  using ::std::swap;
  swap(a.isReadOnly, b.isReadOnly);
  swap(a.file, b.file);
  swap(a.bytes, b.bytes);
  swap(a.__isset, b.__isset);
}

PostDataElement::PostDataElement(const PostDataElement& other14) {
  isReadOnly = other14.isReadOnly;
  file = other14.file;
  bytes = other14.bytes;
  __isset = other14.__isset;
}
PostDataElement& PostDataElement::operator=(const PostDataElement& other15) {
  isReadOnly = other15.isReadOnly;
  file = other15.file;
  bytes = other15.bytes;
  __isset = other15.__isset;
  return *this;
}
void PostDataElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PostDataElement(";
  out << "isReadOnly=" << to_string(isReadOnly);
  out << ", " << "file="; (__isset.file ? (out << to_string(file)) : (out << "<null>"));
  out << ", " << "bytes="; (__isset.bytes ? (out << to_string(bytes)) : (out << "<null>"));
  out << ")";
}


PostData::~PostData() noexcept {
}


void PostData::__set_isReadOnly(const bool val) {
  this->isReadOnly = val;
}

void PostData::__set_hasExcludedElements(const bool val) {
  this->hasExcludedElements = val;
}

void PostData::__set_elements(const std::vector<PostDataElement> & val) {
  this->elements = val;
__isset.elements = true;
}
std::ostream& operator<<(std::ostream& out, const PostData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PostData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isReadOnly = false;
  bool isset_hasExcludedElements = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isReadOnly);
          isset_isReadOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasExcludedElements);
          isset_hasExcludedElements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->elements.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->elements.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->elements[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.elements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isReadOnly)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasExcludedElements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PostData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PostData");

  xfer += oprot->writeFieldBegin("isReadOnly", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isReadOnly);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasExcludedElements", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasExcludedElements);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.elements) {
    xfer += oprot->writeFieldBegin("elements", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->elements.size()));
      std::vector<PostDataElement> ::const_iterator _iter21;
      for (_iter21 = this->elements.begin(); _iter21 != this->elements.end(); ++_iter21)
      {
        xfer += (*_iter21).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PostData &a, PostData &b) {
  using ::std::swap;
  swap(a.isReadOnly, b.isReadOnly);
  swap(a.hasExcludedElements, b.hasExcludedElements);
  swap(a.elements, b.elements);
  swap(a.__isset, b.__isset);
}

PostData::PostData(const PostData& other22) {
  isReadOnly = other22.isReadOnly;
  hasExcludedElements = other22.hasExcludedElements;
  elements = other22.elements;
  __isset = other22.__isset;
}
PostData& PostData::operator=(const PostData& other23) {
  isReadOnly = other23.isReadOnly;
  hasExcludedElements = other23.hasExcludedElements;
  elements = other23.elements;
  __isset = other23.__isset;
  return *this;
}
void PostData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PostData(";
  out << "isReadOnly=" << to_string(isReadOnly);
  out << ", " << "hasExcludedElements=" << to_string(hasExcludedElements);
  out << ", " << "elements="; (__isset.elements ? (out << to_string(elements)) : (out << "<null>"));
  out << ")";
}


KeyEvent::~KeyEvent() noexcept {
}


void KeyEvent::__set_type(const std::string& val) {
  this->type = val;
}

void KeyEvent::__set_modifiers(const int32_t val) {
  this->modifiers = val;
}

void KeyEvent::__set_windows_key_code(const int32_t val) {
  this->windows_key_code = val;
}

void KeyEvent::__set_native_key_code(const int32_t val) {
  this->native_key_code = val;
}

void KeyEvent::__set_is_system_key(const bool val) {
  this->is_system_key = val;
}

void KeyEvent::__set_character(const int16_t val) {
  this->character = val;
}

void KeyEvent::__set_unmodified_character(const int16_t val) {
  this->unmodified_character = val;
}

void KeyEvent::__set_focus_on_editable_field(const bool val) {
  this->focus_on_editable_field = val;
}
std::ostream& operator<<(std::ostream& out, const KeyEvent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KeyEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_modifiers = false;
  bool isset_windows_key_code = false;
  bool isset_native_key_code = false;
  bool isset_is_system_key = false;
  bool isset_character = false;
  bool isset_unmodified_character = false;
  bool isset_focus_on_editable_field = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->modifiers);
          isset_modifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->windows_key_code);
          isset_windows_key_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->native_key_code);
          isset_native_key_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system_key);
          isset_is_system_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->character);
          isset_character = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->unmodified_character);
          isset_unmodified_character = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->focus_on_editable_field);
          isset_focus_on_editable_field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_modifiers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_windows_key_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_native_key_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_system_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_character)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unmodified_character)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_focus_on_editable_field)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeyEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KeyEvent");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modifiers", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->modifiers);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("windows_key_code", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->windows_key_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("native_key_code", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->native_key_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_system_key", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_system_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("character", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->character);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unmodified_character", ::apache::thrift::protocol::T_I16, 7);
  xfer += oprot->writeI16(this->unmodified_character);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("focus_on_editable_field", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->focus_on_editable_field);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyEvent &a, KeyEvent &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.modifiers, b.modifiers);
  swap(a.windows_key_code, b.windows_key_code);
  swap(a.native_key_code, b.native_key_code);
  swap(a.is_system_key, b.is_system_key);
  swap(a.character, b.character);
  swap(a.unmodified_character, b.unmodified_character);
  swap(a.focus_on_editable_field, b.focus_on_editable_field);
}

KeyEvent::KeyEvent(const KeyEvent& other24) {
  type = other24.type;
  modifiers = other24.modifiers;
  windows_key_code = other24.windows_key_code;
  native_key_code = other24.native_key_code;
  is_system_key = other24.is_system_key;
  character = other24.character;
  unmodified_character = other24.unmodified_character;
  focus_on_editable_field = other24.focus_on_editable_field;
}
KeyEvent& KeyEvent::operator=(const KeyEvent& other25) {
  type = other25.type;
  modifiers = other25.modifiers;
  windows_key_code = other25.windows_key_code;
  native_key_code = other25.native_key_code;
  is_system_key = other25.is_system_key;
  character = other25.character;
  unmodified_character = other25.unmodified_character;
  focus_on_editable_field = other25.focus_on_editable_field;
  return *this;
}
void KeyEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KeyEvent(";
  out << "type=" << to_string(type);
  out << ", " << "modifiers=" << to_string(modifiers);
  out << ", " << "windows_key_code=" << to_string(windows_key_code);
  out << ", " << "native_key_code=" << to_string(native_key_code);
  out << ", " << "is_system_key=" << to_string(is_system_key);
  out << ", " << "character=" << to_string(character);
  out << ", " << "unmodified_character=" << to_string(unmodified_character);
  out << ", " << "focus_on_editable_field=" << to_string(focus_on_editable_field);
  out << ")";
}

} // namespace
